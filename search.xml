<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python3 基础运算]]></title>
    <url>%2F2020%2F03%2F05%2Fpython%2Fpython03%2F</url>
    <content type="text"><![CDATA[前言:包括条件控制if – elif – else、循环语句for和while、迭代器与生成器等内容的介绍与基本操作 条件控制 if – elif – elseifPython中用elif代替了else if，所以if语句的关键字为：if – elif – else 123456if condition_1: # 条件1：condition_1 statement_block_1 # 逻辑1：statement_block_1elif condition_2: # 条件2：condition_2 statement_block_2 # 逻辑2：statement_block_2else: statement_block_3 # 逻辑3：statement_block_3 每个条件后面要使用冒号:，表示接下来是满足条件后要执行的语句块 使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块 在Python中没有switch – case语句 条件为真：1,非零数值,True, 非空字符串,至少有一个元素的容器对象,非None对象 条件为假：0,0.0, False, ‘’(空字符串),[],(),{},set(),Noneif嵌套在嵌套if语句中，可以把if...elif...else结构放在另外一个if...elif...else结构中1234567891011num=int(input("输入一个数字："))if num%2==0: if num%3==0: print ("你输入的数字可以整除 2 和 3") else: print ("你输入的数字可以整除 2，但不能整除 3")else: if num%3==0: print ("你输入的数字可以整除 3，但不能整除 2") else: print ("你输入的数字不能整除 2 和 3") 输出结果： 123$ python3 test.py 输入一个数字：6你输入的数字可以整除 2 和 3 循环语句 for 和 whilePython中的循环语句有for和while while语句(1)基本用法：计算 1 到 100 的总和(5050): 12345n,sum,counter = 100,0,1while counter &lt;= n: sum = sum + counter counter += 1print("1 到 %d 之和为: %d" % (n,sum)) (2)while 循环使用 else 语句：在while … else在条件语句为false时执行else的语句块: 123456count = 0while count &lt; 5: print (count, " 小于 5") count+=1else: print (count, " 大于或等于 5") for语句(1)for循环可以遍历任何序列的项目，如一个列表或者一个字符串，for循环的一般格式如下： 1234for &lt;variable&gt; in &lt;sequence&gt;: &lt;statements&gt;else: &lt;statements&gt; (2)for实例中可以使用break语句，break语句用于跳出当前循环体： 123456789sites = ["Baidu", "Google","Runoob","Taobao"]for site in sites: if site == "Runoob": print("菜鸟教程!") break print("循环数据 " + site)else: print("没有循环数据!")print("完成循环!") 输出结果： 1234循环数据 Baidu循环数据 Google菜鸟教程!完成循环! range()函数(1)如果需要遍历数字序列，可以使用内置range()函数，它会生成数列： 12for i in range(5): print(i,end=' ') # 0 1 2 3 4 (2)range指定区间的值： 12for i in range(5,9) : print(i,end=' ') # 5 6 7 8 (3)range以指定数字开始并指定不同的增量(甚至可以是负数，有时这也叫做’步长’)： 1234for i in range(0,10,3) : print(i,end=' ') # 0 3 6 9for i in range(-10,-100,-30) : print(i,end=' ') # -10 -40 -70 (4)结合range()和len()函数以遍历一个序列的索引,如下所示： 123a = ['Google', 'Baidu', 'Runoob', 'Taobao', 'QQ']for i in range(len(a)): print(i, a[i],end=' | ') # 0 Google | 1 Baidu | 2 Runoob | 3 Taobao | 4 QQ | break 和 continue 语句及循环中的 else 子句(1)break语句可以跳出for和while的循环体。如果你从for或while循环中终止，任何对应的循环else块将不执行 1234567n = 5while n &gt; 0: n -= 1 if n == 2: break print(n,end=' ')print('循环结束') # 4 3 循环结束 (2) continue 语句被用来告诉Python跳过当前循环块中的剩余语句，然后继续进行下一轮循环 1234567n = 5while n &gt; 0: n -= 1 if n == 2: continue print(n,end=' ')print('循环结束') # 4 3 1 0 循环结束 循环语句可以有else子句，它在穷尽列表(以for循环)或条件变为false(以while循环)导致循环终止时被执行，但循环被break终止时不执行 (3)冒泡排序： 1234567891011121314151617def maopao_sort(li): max=0 print('排序前：',li) for i in range(len(li)-1): for j in range(len(li)-1-i): if li[j]&gt;li[j+1]: max=li[j] li[j]=li[j+1] li[j+1]=max else: max=li[j+1] print('排序后：',li)li=[41,23344,9353,5554,44,7557,6434,500,2000]maopao_sort(li)# 排序前： [41, 23344, 9353, 5554, 44, 7557, 6434, 500, 2000]# 排序后： [41, 44, 500, 2000, 5554, 6434, 7557, 9353, 23344] pass 语句(1) pass是空语句，是为了保持程序结构的完整性，pass不做任何事情，一般用做占位语句 123456for letter in 'Runoob': if letter == 'o': pass print (end='**pass**') print (' 字母 :', letter,end=' | ')print ("循环结束") # 字母 : R | 字母 : u | 字母 : n | **pass** 字母 : o | **pass** 字母 : o | 字母 : b | 循环结束 迭代器(1)迭代是Python最强大的功能之一，是访问集合元素的一种方式，迭代器是一个可以记住遍历的位置的对象(2)迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束，迭代器只能往前不会后退(3)迭代器有两个基本的方法：iter()和next()，字符串，列表或元组对象都可用于创建迭代器 1234list=[1,2,3,4]it = iter(list) # 创建迭代器对象for i in it: print( i, end=' | ') # 1 | 2 | 3 | 4 | 创建迭代器(1)把一个类作为一个迭代器使用需要在类中实现两个方法__iter__()与__next__()(2)__iter__()方法返回一个特殊的迭代器对象， 这个迭代器对象实现了__next__()方法并通过StopIteration异常标识迭代的完成(3)__next__()方法（Python 2 里是next()）会返回下一个迭代器对象 1234567891011121314class MyNumbers: # 创建一个返回数字的迭代器，初始值为 1，逐步递增 3 def __iter__(self): self.a = 1 return self def __next__(self): x = self.a self.a += 3 return xmyclass = MyNumbers()myiter = iter(myclass)for i in range(5): print('第 ', i, ' 次迭代值为：', next(myiter)) 输出结果： 12345第 0 次迭代值为： 1第 1 次迭代值为： 4第 2 次迭代值为： 7第 3 次迭代值为： 10第 4 次迭代值为： 13 StopIteration(1)StopIteration异常用于标识迭代的完成，防止出现无限循环的情况，在__next__()方法中我们可以设置在完成指定循环次数后触发StopIteration异常来结束迭代 123456789101112131415161718class MyNumbers: # 创建一个返回数字的迭代器，初始值为 1，逐步递增 3, 4次迭代后停止执行 def __iter__(self): self.a,self.b = 1,1 # a为返回值，b为计数器 return self def __next__(self): if self.b&lt;20: self.b += 1 x = self.a self.a += 3 return x else: raise StopIterationmyclass = MyNumbers()myiter = iter(myclass)for i in myiter: print(i,end=' | ') # 1 | 4 | 7 | 10 | 13 | 16 | 19 | 生成器(1)使用了yield的函数被称为生成器generator(2)跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器(3)在调用生成器运行的过程中，每次遇到yield时函数会暂停并保存当前所有的运行信息，返回yield的值, 并在下一次执行next()方法时从当前位置继续运行(4)调用一个生成器函数，返回的是一个迭代器对象，如下斐波那契数列打印使用和不使用yield进行比较使用yield： 1234567891011121314151617181920import sysdef fibonacci(n, w=0): # 生成器函数 - 斐波那契 a, b, counter = 0, 1, 0 while True: if (counter &gt; n): return yield a # 使用yield print('a = ', a, end=' | ') a, b = b, a + b print('a = ', a, ' b = ', b) counter += 1f = fibonacci(10, 0) # f 是一个迭代器，由生成器返回生成while True: try: print(next(f), end=" ") except: sys.exit() 输出结果： 12345678910110 a = 0 | a = 1 b = 11 a = 1 | a = 1 b = 21 a = 1 | a = 2 b = 32 a = 2 | a = 3 b = 53 a = 3 | a = 5 b = 85 a = 5 | a = 8 b = 138 a = 8 | a = 13 b = 2113 a = 13 | a = 21 b = 3421 a = 21 | a = 34 b = 5534 a = 34 | a = 55 b = 8955 a = 55 | a = 89 b = 144 不使用yield： 1234567891011121314151617181920import sysdef fibonacci(n, w=0): # 生成器函数 - 斐波那契 a, b, counter = 0, 1, 0 while True: if (counter &gt; n): return # yield a # 不使用yield，函数只是简单执行，没有返回迭代器f print('a = ', a, end=' | ') a, b = b, a + b print('a = ', a, ' b = ', b) counter += 1f = fibonacci(10, 0) # f 是一个迭代器，由生成器返回生成while True: try: print(next(f), end=" ") except: sys.exit() 输出结果： 1234567891011a = 0 | a = 1 b = 1a = 1 | a = 1 b = 2a = 1 | a = 2 b = 3a = 2 | a = 3 b = 5a = 3 | a = 5 b = 8a = 5 | a = 8 b = 13a = 8 | a = 13 b = 21a = 13 | a = 21 b = 34a = 21 | a = 34 b = 55a = 34 | a = 55 b = 89a = 55 | a = 89 b = 144 (5)yield使用场景：一个函数fab，fab返回一个list，这个list是动态计算出来的，并且这个list会很大（无论是固定很大还是随着输入参数的增大而增大），这个时候，我们希望每次调用这个函数并使用迭代器进行循环的时候一个一个的得到每个list元素而不是直接得到一个完整的list来节省内存，这个时候yield就很有用以斐波那契函数为例，我们一般希望从n返回一个n个数的list 1234567891011def fab(max): # 简单输出斐波那契数列前 max 个数 n, a, b = 0, 0, 1 L = [] while n &lt; max: L.append(b) a, b = b, a + b n = n + 1 return L for n in fab(100): print n fab函数从参数max返回一个有max个元素的list，当这个max很大的时候，会非常的占用内存如果使用list的迭代器。那么我们可以让这个函数fab每次只返回一个迭代器(一个计算结果)，而不是一个完整的list，运行方式是每次的调用都在yield处中断并返回一个结果，然后再次调用的时候再恢复中断继续运行： 12345678910def fab(max): # 简单输出斐波那契数列前 max 个数 n, a, b = 0, 0, 1 while n &lt; max: yield b # print b a, b = b, a + b n = n + 1 for n in fab(100): print n]]></content>
      <categories>
        <category>Python</category>
        <category>Study</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 基本数据类型]]></title>
    <url>%2F2020%2F03%2F03%2Fpython%2Fpython02%2F</url>
    <content type="text"><![CDATA[前言:Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建;在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型 Python 变量类型(1)变量存储在内存中的值，这就意味着在创建变量时会在内存中开辟一个空间(2)基于变量的数据类型，解释器会分配指定内存，并决定什么数据可以被存储在内存中(3)因此，变量可以指定不同的数据类型，这些变量可以存储整数，小数或字符 变量赋值(1)Python 中的变量赋值不需要类型声明(2)每个变量在内存中创建，都包括变量的标识，名称和数据这些信息(3)每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建(4)等号=用来给变量赋值(5)等号=运算符左边是一个变量名,等号=运算符右边是存储在变量中的值 123456counter = 100 # 赋值整型变量miles = 1000.0 # 浮点型name = "John" # 字符串print("整数："+str(counter))print("浮点数："+str(miles))print("字符串："+str(name)) 输出结果： 123整数：100浮点数：1000.0字符串：John 多个变量赋值(1)Python允许你同时为多个变量赋值，例如：创建一个整型对象，值为1，三个变量被分配到相同的内存空间上 123&gt;&gt;&gt; a = b = c = 1&gt;&gt;&gt; print(a+b+c)3 (2)多个对象指定多个变量，例如：两个整型对象1和2分别分配给变量a和b，字符串对象john分配给变量c 123&gt;&gt;&gt; a, b, c = 1, 2, "john"&gt;&gt;&gt; print(str(a)+str(b)+c)12john 标准数据类型(1)Python3定义了*六个标准数据类型，用于存储各种类型的数据： Numbers（数字） String（字符串） List（列表） Tuple（元组） Set（集合） # Python3以下版本无此数据类型 Dictionary（字典） (2) 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）； 可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合） 有序：列表list、字典dict(python3.6之后)、Tuple（元组）、Number（数字）、String（字符串） 无序：字典dict(python3.6之前)、集合set Number（数字）(1)Python3支持int、float、bool、complex（复数）(2)在Python3里，只有一种整数类型int，表示为长整型，没有python2中的Long(3)像大多数语言一样，数值类型的赋值和计算都是很直观的(4)内置的type()函数可以用来查询变量所指的对象类型 123&gt;&gt;&gt; a, b, c, d = 20, 5.5, True, 4+3j&gt;&gt;&gt; print(type(a), type(b), type(c), type(d))&lt;class 'int'&gt; &lt;class 'float'&gt; &lt;class 'bool'&gt; &lt;class 'complex'&gt; (5)此外还可以用isinstance来判断类型 123&gt;&gt;&gt; a,b = 111,'111'&gt;&gt;&gt; print('a是不是整型：',isinstance(a, int),'b是不是整型：',isinstance(b, int))a是不是整型： True b是不是整型： False (6)isinstance和type的区别在于： type()不会认为子类是一种父类类型。 isinstance()会认为子类是一种父类类型1234567891011121314&gt;&gt;&gt; class A:... pass... &gt;&gt;&gt; class B(A):... pass... &gt;&gt;&gt; isinstance(A(), A)True&gt;&gt;&gt; type(A()) == A True&gt;&gt;&gt; isinstance(B(), A)True&gt;&gt;&gt; type(B()) == AFalse 注意：在Python2中是没有布尔型的，它用数字0表示False，用1表示True。到Python3中，把True和False定义成关键字了，但它们的值还是1和0，它们可以和数字相加(7)使用del语句删除一些对象引用，del语句的语法是： 123del var1[,var2[,var3[....,varN]]] # del语语法del var # del语句删除单个对象del var_a, var_b # del语句删除多个对象 数值运算1234567891011121314&gt;&gt;&gt; 5 + 4 # 加法9&gt;&gt;&gt; 4.3 - 2 # 减法2.3&gt;&gt;&gt; 3 * 7 # 乘法21&gt;&gt;&gt; 2 / 4 # 除法，得到一个浮点数0.5&gt;&gt;&gt; 17 // 3# 除法，得到一个整数5&gt;&gt;&gt; 17 % 3 # 取余 2&gt;&gt;&gt; 2 ** 5 # 乘方32 Python可以同时为多个变量赋值，如a, b = 1, 2 一个变量可以通过赋值指向不同类型的对象 数值的除法包含两个运算符/返回一个浮点数，//返回一个整数 在混合计算时，Python会把整型转换成为浮点数 数值类型实例 int float complex 10 0.0 3.14j 100 15.20 45.j -786 -21.9 9.322e-36j 080 32.3e+18 .876j -0490 -90. -.6545+0J -0x260 -32.54e100 3e+26J 0x69 70.2E-12 4.53e-7j Python还支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示，复数的实部a和虚部b都是浮点型 数学函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import mathimport randomx,y = 10,20list1=[9,4,7,3,8,5,1,6]# 数学函数print('abs(-10):',abs(-10)) # 返回数字的绝对值，如abs(-10) 返回 10print('math.fabs(-10):',math.fabs(-10)) # 返回数字的绝对值，如math.fabs(-10) 返回10.0print('max(list1):',max(list1)) # 返回给定参数的最大值，参数可以为序列(列表等)print('min(list1):',min(list1)) # 返回给定参数的最小值，参数可以为序列(列表等)print('(x&gt;y)-(x&lt;y):',(x&gt;y)-(x&lt;y)) # 如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。 Python 3 已废弃，使用 (x&gt;y)-(x&lt;y) 替换print('math.exp(1):',math.exp(1)) # 返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045print('math.ceil(4.1):',math.ceil(4.1)) # 返回数字的上入整数，如math.ceil(4.1) 返回 5print('math.floor(4.9):',math.floor(4.9)) # 返回数字的下舍整数，如math.floor(4.9)返回 4print ("math.pow(2, 4):", math.pow(2, 4)) # x**y 运算后的值，math.pow(2, 4)返回16.0print ("round(70.23456):", round(70.23456,4)) # 返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数，其实准确的说是保留值将保留到离上一位更近的一端print ("math.sqrt(100): ", math.sqrt(100)) # 返回数字x的平方根，math.sqrt(100)返回10.0print ("math.modf(100.12): ", math.modf(100.12)) # 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示print('math.log(32,2):',math.log(32,2)) # log() 方法返回x的自然对数，如math.log(math.e)返回1.0,math.log(32,2)返回5.0print('math.log10(10000):',math.log10(10000)) # 返回以10为基数的x的对数，如math.log10(10000)返回 4.0# 随机数函数(随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性)# random.choice(seq)函数：从序列(可以是一个列表，元组或字符串)的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数print ("从 range(100) 返回一个随机数 : ",random.choice(range(100)))print ("从列表中 [1, 2, 3, 5, 9]) 返回一个随机元素 : ", random.choice([1, 2, 3, 5, 9]))print ("从字符串中 'Runoob' 返回一个随机字符 : ", random.choice('Runoob'))# random.randrange ([start,] stop [,step])：从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1print ("randrange(1,100, 2) : ", random.randrange(1, 100, 2)) # 从 1-100 中选取一个奇数print ("randrange(100) : ", random.randrange(100)) # 从 0-99 选取一个随机数# random.random()：随机生成下一个实数，它在[0,1)范围内print ("random() : ", random.random()) # 随机生成一个[0,1)的实数print ("random() : ", (random.random()*10+1)) # 随机生成一个[0,10]的实数# random.seed ( [x] ): 方法改变随机数生成器的种子，可以在调用其他随机模块函数之前调用此函数.# 预先使用 random.seed(x) 设定好种子之后，其中的 x 可以是任意数字，如10，这个时候，先调用它的情况下，使用 random() 生成的随机数将会是同一个random.seed(10)print ("使用整数 10 种子生成随机数：", random.random()) # 产生一个随机数random.seed(10)print ("使用整数 10 种子生成随机数：", random.random()) # 和上一个随机数一致# random.shuffle (lst)：将序列的所有元素随机排序，lst为列表，函数返回 Nonerandom.shuffle(list1); # 随机排序列表print ("随机排序列表1 : ", list1)random.shuffle(list1) # 随机排序列表print ("随机排序列表3 : ", list1)# random.uniform(x, y)：随机生成下一个实数，它在[x,y]范围内，返回一个浮点数 N，取值范围为如果 x&lt;y 则 x &lt;= N &lt;= y，如果 y&lt;x 则y &lt;= N &lt;= xprint ("uniform(5, 10) 的随机浮点数 : ", random.uniform(5, 10))print ("生成两位小数的浮点数 : ", round(random.uniform(5, 10), 2))# 三角函数print ("cos(0) : ", math.cos(0)) # 返回x的弧度的余弦值 返回x的弧度的余弦值,-1 到 1 之间print ("acos(1) : ", math.acos(1)) # 返回x的反余弦弧度值 x为-1到1之间的数值。如果x是大于1，会产生一个错误print ("sin(math.pi/2) : ", math.sin(math.pi/2)) # 返回的x弧度的正弦值 返回的x弧度的正弦值，数值在 -1 到 1 之间print ("asin(0) : ", math.asin(0)) # 返回x的反正弦弧度值 x为-1到1之间的数值。如果x是大于1，会产生一个错误print ("tan(0) : ", math.tan(0)) # 返回x弧度的正切值 返回的x弧度的正弦值，数值在 -1 到 1 之间print ("atan(0.64) : ", math.atan(0.64)) # 返回x的反正切弧度值print ("atan2(5,5) : ", math.atan2(5,5)) # 返回给定的 X 及 Y 坐标值的反正切值print ("hypot(0, 2) : ", math.hypot(0, 2)) # 返回欧几里德范数 sqrt(x*x + y*y)print ("degrees(math.pi/2) : ", math.degrees(math.pi/2)) # 将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0print ("radians(math.pi/2) : ", math.radians(math.pi/2)) # 将角度转换为弧度# 数学常量print('pi：',math.pi) # 数学常量 pi（圆周率，一般以π来表示）print('e：',math.e) # 数学常量 e，e即自然常数（自然常数） String（字符串）(1)Python中的字符串用单引号&#39;或双引号&quot;括起来，同时使用反斜杠\转义特殊字符(2)索引值以0为开始值，-1为从末尾的开始位置(3)加号+是字符串的连接符，星号*表示复制当前字符串，与之结合的数字为复制的次数(4)Python使用反斜杠\转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个r，表示原始字符串 123456789101112131415161718192021222324&gt;&gt;&gt;str = 'Runoob'&gt;&gt;&gt;print (str) # 输出字符串Runoob&gt;&gt;&gt;print (str[0:-1]) # 输出第一个到倒数第二个的所有字符Runoo&gt;&gt;&gt;print (str[0]) # 输出字符串第一个字符R&gt;&gt;&gt;print (str[2:5]) # 输出从第三个开始到第五个的字符noo&gt;&gt;&gt;print (str[2:]) # 输出从第三个开始的后的所有字符noob&gt;&gt;&gt;print (str * 2) # 输出字符串两次，也可以写成 print (2 * str) RunoobRunoob&gt;&gt;&gt;print (str + "TEST") # 连接字符串RunoobTEST&gt;&gt;&gt;print ('Ru\noob') # 反斜杠 \ 转义特殊字符Ruoob&gt;&gt;&gt;print (r'Ru\noob') # 字符串前面添加一个 r，表示原始字符串，不让反斜杠发生转义Ru \n oob&gt;&gt;&gt;inputStr = '123 456 789'&gt;&gt;&gt;inputStr=inputStr[-1::-1] # 字符串逆置&gt;&gt;&gt;print(inputStr)987 654 321 (5)Python没有单独的字符类型，一个字符就是长度为1的字符串(6)Python字符串不能被改变，向一个索引位置赋值，比如word[0]=&#39;m&#39;会导致错误 12345&gt;&gt;&gt; word = 'Python'&gt;&gt;&gt; print(word[0], word[5])P n&gt;&gt;&gt; print(word[-1], word[-6])n P Python字符串格式化(1)Python支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符%s的字符串中 12&gt;&gt;&gt;print ("我叫 %s 今年 %d 岁!" % ('小明', 10))我叫 小明 今年 10 岁! (2)Python字符串格式化符号 int float %c 格式化字符及其ASCII码 %d 格式化字符串 %d 格式化整数 %u 格式化无符号整型 %o 格式化无符号八进制数 %x 格式化无符号十六进制数 %X 格式化无符号十六进制数（大写） %f 格式化浮点数字，可指定小数点后的精度 %e 用科学计数法格式化浮点数 %E 作用同%e，用科学计数法格式化浮点数 %g %f和%e的简写 %G %f 和 %E 的简写 %p 用十六进制数格式化变量的地址 f-string(1)f-string是python3.6之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法,之前我们习惯用百分号(%)(2)f-string格式化字符串以f开头，后面跟着字符串，字符串中的表达式用大括号{}包起来，它会将变量或表达式计算后的值替换进去，实例如下 123&gt;&gt;&gt; name = 'Runoob'&gt;&gt;&gt; 'Hello %s' % name'Hello Runoob' (3)用了f-string方式显得更简单，不用再去判断使用%s，还是%d(4)在Python 3.8的版本中可以使用 = 符号来拼接运算表达式与结果 123456&gt;&gt;&gt; x = 1&gt;&gt;&gt; print(f'&#123;x+1&#125;') # Python 3.62&gt;&gt;&gt; x = 1&gt;&gt;&gt; print(f'&#123;x+1=&#125;') # Python 3.8'x+1=2' 字符串内建函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148# Python 的字符串内建函数，Python 的字符串常用内建函数如下：string = 'Hello World'# capitalize()：该方法返回一个首字母大写的字符串# (1)首字符会转换成大写，其余字符会转换成小写# (2)首字符如果是非字母，首字母不会转换成大写，会转换成小写print ("str.capitalize() : ", 'lu XIONG'.capitalize()) # 输出：str.capitalize() : Lu xiongprint ("str.capitalize() : ", '123 Lu XIONG'.capitalize()) # 输出：str.capitalize() : 123 lu xiong# center(width[, fillchar])：返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格.如果 width 小于字符串宽度直接返回字符串print ("str.center(40, '*') : ", '[runoob]'.center(40, '*')) # 输出：str.center(40, '*') : ****************[runoob]****************# ljust(width[, fillchar])：返回一个原字符串左对齐,并使用空格(fillchar填充字符，默认为空格)填充至指定长度(width)的新字符串，如果指定的长度小于原字符串的长度则返回原字符串print ('大帅哥'.ljust(40, '*')) # 输出：大帅哥*************************************# rjust(width[, fillchar])：返回一个原字符串右对齐,并使用空格(fillchar填充字符，默认为空格)填充至指定长度(width)的新字符串，如果指定的长度小于原字符串的长度则返回原字符串print ('大帅哥'.rjust(40, '*')) # 输出：*************************************大帅哥# zfill(width)：返回指定长度的字符串，原字符串右对齐，前面填充0(作用同 rjust(width,"0"))print ('大帅哥'.zfill(40)) # 输出：0000000000000000000000000000000000000大帅哥# count(sub, start= 0,end=len(string))：返回回子字符串(sub)在字符串中出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数print ("str.count('o') : ", 'www.runoob.com'.count('o',0,10)) # 输出：str.count('o') : 2 # find(str, beg=0, end=len(string))：检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1print("Runoob example....wow!!!".find("exam")) # 输出：7print("Runoob example....wow!!!".find("exam", 5)) # 输出：7print("Runoob example....wow!!!".find("exam", 10)) # 输出：-1# rfind(str, beg=0 end=len(string))：类似于 find()函数，不过是从右边开始查找.返回字符串str最后一次出现的位置，如果没有匹配项则返回-1(beg-开始查找的位置，默认为0 end-结束查找位置，默认为字符串的长度)print ('abcdefghijklmnopqrstubvwxyz 中 b 最后一次出现在：','abcdefghijklmnopqrstubvwxyz'.rfind('b',0,20)) # 输出：aa bb aa bb aa bb aa bb中 bb 最后一次出现在： 9print ('abcdefghijklmnopqrstubvwxyz 中 b 最后一次出现在：','abcdefghijklmnopqrstubvwxyz'.find('b',0,20)) # 输出：aa bb aa bb aa bb aa bb中 bb 最后一次出现在： 3# # index(str, beg=0, end=len(string))：跟find()方法一样，只不过如果str不在字符串中会报一个异常# print("Runoob example....wow!!!".index("exam")) # 输出：7# print("Runoob example....wow!!!".index("exam", 5)) # 输出：7# print("Runoob example....wow!!!".index("exam", 10)) # 输出：ValueError: substring not found# # rindex(str, beg=0, end=len(string))：类似于 find()函数，不过是从右边开始查找.跟find()方法一样，只不过如果str不在字符串中会报一个异常# print("Runoob example....wow!!!".rindex("exam")) # 输出：7# print("Runoob example....wow!!!".rindex("exam", 5)) # 输出：7# print("Runoob example....wow!!!".rindex("exam", 10)) # 输出：ValueError: substring not found# isalnum()：检测字符串是否由字母和数字组成，如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True,否则返回 Falseprint('runoob2016 是不是都是字母或者数字：',"runoob2016".isalnum()) # 输出：runoob2016 是不是都是字母或者数字： Trueprint('www.runoob.com 是不是都是字母或者数字：',"www.runoob.com".isalnum()) # 输出：www.runoob.com 是不是都是字母或者数字： False# isalpha()：检测字符串是否只由字母或文字组成，如果字符串至少有一个字符并且所有字符都是字母则返回 True, 否则返回 Falseprint('runoob菜鸟教程 是不是都是字母或者文字组成：', "runoob菜鸟教程".isalnum()) # 输出：runoob2016 是不是都是字母或者数字： Trueprint('Runoob example....wow!!! 是不是都是字母或者数字：', "Runoob example....wow!!!".isalnum()) # 输出：www.runoob.com 是不是都是字母或者数字： False# isdigit()：检测字符串是否只由数字组成，如果字符串只包含数字则返回 True 否则返回 Falseprint('12985 是不是都是数字：', '12985'.isdigit()) # 输出：12985 是不是都是数字： Trueprint('runoo 是不是都是数字：', "runoo".isdigit()) # 输出：12985 是不是都是数字： False# isdecimal()：检测字符串是否只包含十进制字符。这种方法只存在于unicode对象。注：定义一个十进制字符串，只需要在字符串前添加 'u' 前缀即可print('12985 是不是都是十进制字符：', '12985'.isdecimal()) # 输出：12985 是不是都是十进制字符： Trueprint('129ww 是不是都是十进制字符：', '129ww'.isdecimal()) # 输出：129ww 是不是都是十进制字符： False# islower()：检测字符串是否由小写字母组成，如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 Falseprint('12uno1 的字母是不是都是小写字母：', '12uno1'.islower()) # 输出：12uno1 的字母是不是小写字母： Trueprint('ruNoo 的字母是不是都是小写字母：', "ruNoo".islower()) # 输出：runoo 的字母是不是都是小写字母： False# isupper()：检测字符串中所有的字母是否都为大写，如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 Falseprint('12ABC 的字母是不是都是大写字母：', '12ABC'.isupper()) # 输出：12ABC 的字母是不是小写字母： Trueprint('abCDE 的字母是不是都是大写字母：', "abCDE".isupper()) # 输出：abCDE 的字母是不是都是小写字母： False# lower()：转换字符串中所有大写字符为小写，返回将字符串中所有大写字符转换为小写后生成的字符串print( "Runoob EXAMPLE....WOW!!!".lower()) # 输出：runoob example....wow!!!# upper()：转换字符串中所有大写字符为大写，返回将字符串中所有小写字符转换为大写后生成的字符串print( "this is string".upper()) # 输出：THIS IS STRING# swapcase()：用于对字符串的大小写字母进行转换，返回大小写字母转换后生成的新字符串print ('This Is String'.swapcase()) # 输出：tHIS iS sTRING# isnumeric()：测字符串是否只由数字组成，数字可以是： Unicode 数字，全角数字（双字节），罗马数字，汉字数字。指数类似 ² 与分数类似 ½ 也属于数字.如果字符串中只包含数字字符，则返回 True，否则返回 Falseprint('222666 是不是只包含数字字符：', '222666'.isnumeric()) # 输出：222666 是不是只包含数字字符： Trueprint('222abc 是不是只包含数字字符：', "222abc".isnumeric()) # 输出：222abc 是不是只包含数字字符： False# isspace()：检测字符串是否只由空白字符组成，如果字符串中只包含空格，则返回 True，否则返回 Falseprint(' '.isspace()) # 输出：Trueprint(' a '.isspace()) # 输出：False# istitle()：检测字符串中所有的单词拼写首字母是否为大写，且其他字母为小写，如果字符串中所有的单词拼写首字母是否为大写，且其他字母为小写则返回 True，否则返回 Falseprint('Hello World'.istitle()) # 输出：Trueprint('Hello world'.istitle()) # 输出：False# title()：返回"标题化"的字符串,就是说所有单词的首个字母转化为大写，其余字母均为小写print('this is string'.title()) # 输出：This Is String# join()：用于将序列中的元素以指定的字符连接生成一个新的字符串，返回通过指定字符连接序列中元素后生成的新字符串print('-'.join(list('World'))) # 输出：W-o-r-l-dprint(' '.join(list('World'))) # 输出：W o r l d# len()：返回对象（字符、列表、元组等）长度或项目个数print('Hello World 的长度为：'+str(len('Hello World'))) # 输出：Hello World 的长度为：11# lstrip([chars])：用于截掉字符串左边的空格或指定字符(chars)，返回截掉字符串左边的空格或指定字符后生成的新字符串print(' this is string'.lstrip()) # 输出：this is stringprint('889999988this is string999'.lstrip('89')) # 输出：this is string999# rstrip([chars])：用于截掉字符串右边的空格或指定字符(chars)，返回截掉字符串右边的空格或指定字符后生成的新字符串print('this is string '.rstrip()) # 输出：this is stringprint('889999988this is string889999988'.rstrip('89')) # 输出：889999988this is string# strip([chars])：用于移除字符串头尾指定的字符（默认为空格）或字符序列。该方法只能删除开头或是结尾的字符，不能删除中间部分的字符(相当于执行 lstrip()和 rstrip())print(' this is string '.strip()) # 输出：this is stringprint('889999988this is string889999988'.strip('89')) # 输出：this is string# str.maketrans(intab, outtab)：用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标# 两个字符串的长度必须相同，为一一对应的关系# Python3.4 已经没有 string.maketrans() 了，取而代之的是内建函数: bytearray.maketrans()、bytes.maketrans()、str.maketrans()print ('在字符串 just do it 中，将abcdefs对应的字符转化为1234567的结果是： ','just do it'.translate(str.maketrans('abcdefs','1234567'))) # 输出：在字符串 just do it 中，将abcdefs对应的字符转化为1234567的结果是： ju7t 4o it# translate(table[, delete])：根据参数table(table:翻译表是通过 maketrans() 方法转换而来)转换字符串的字符,要过滤掉的字符放到 deletechars 参数中print ('在字符串 just do it 中，将abcdefs对应的字符转化为1234567的结果是： ','just do it'.translate(str.maketrans('abcdefs','1234567'))) # 输出：在字符串 just do it 中，将abcdefs对应的字符转化为1234567的结果是： ju7t 4o itbytes_tabtrans = bytes.maketrans(b'abcdefghijklmnopqrstuvwxyz', b'ABCDEFGHIJKLMNOPQRSTUVWXYZ') # 制作翻译表print ('转换为大写，并删除字母o： ',b'just do it'.translate(bytes_tabtrans, b'o')) # 输出：转换为大写，并删除字母o： b'JUST D IT'# max(str)：返回字符串中最大的字母print ("最大字符: " + max('runoob')) # 输出：最大字符: u# min(str)：返回字符串中最小的字母print ("最小字符: " + min('runoob')) # 输出：最小字符: b# replace(old, new[, max])：把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次print ('将 aa 替换为 cc ，替换次数不超过3次：','aa bb aa bb aa bb aa bb'.replace("aa", "cc", 3)) # 输出：将 aa 替换为 cc ，替换次数不超过3次： cc bb cc bb cc bb aa bb# split(str="", num=string.count(str))：通过指定分隔符(str)对字符串进行切片，如果第二个参数 num 有指定值，则分割为 num+1 个子字符串，返回分割后的字符串列表print ('Google#Runoob#Taobao#Facebook 用#分割俩次结果为：',"Google#Runoob#Taobao#Facebook".split('#',2)) # 输出：Google#Runoob#Taobao#Facebook 用#分割俩次结果为： ['Google', 'Runoob', 'Taobao#Facebook']# splitlines([keepends])：按照行('\r', '\r\n', \n')分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符print ('保留换行符：','ab c\n\nde fg\rkl\r\n'.splitlines(True)) # 输出：保留换行符：['ab c\n', '\n', 'de fg\r', 'kl\r\n']print ('保留换行符：','ab c\n\nde fg\rkl\r\n'.splitlines()) # 输出：保留换行符：['ab c', '', 'de fg', 'kl']# startswith(substr, beg=0,end=len(string))：检查字符串是否是以指定子字符串开头，如果是则返回 True，否则返回 False。如果参数 beg 和 end 指定值，则在指定范围内检查print('aaa bbb ccc索引为 1~6 的子字符串否以 aa 开头：','aaa bbb ccc'.startswith('aa',1,6)) # aaa bbb ccc索引为 1~6 的子字符串否以 aa 开头： Trueprint('aaa bbb ccc是否以 bb 开头：','aaa bbb ccc'.startswith('bb')) # 输出：aaa bbb ccc是否以 bb 开头： False# endswith(suffix[, start[, end]])：判断字符串是否以指定后缀结尾，如果以指定后缀结尾返回 True，否则返回 False。可选参数 "start" 与 "end" 为检索字符串的开始与结束位置print('aaa bbb ccc索引为 1~6 的子字符串否以 bb 结尾：','aaa bbb ccc'.endswith('bb',1,6)) # aaa bbb ccc索引为 1~6 的子字符串否以 bb 结尾 Trueprint('aaa bbb ccc是否以 cc 结尾：','aaa bbb ccc'.endswith('cc')) # 输出：aaa bbb ccc是否以 cc 结尾： True# expandtabs(tabsize=8)：把字符串中的 tab 符号('\t')转为空格，tab 符号('\t')默认的空格数是 8 ，tabsize指定转换字符串中的 tab 符号('\t')转为空格的字符数print("原始字符串: " + "this is\tstring example....wow!!!") # 输出：原始字符串: this is string example....wow!!!print("替换 \\t 符号: " + "this is\tstring example....wow!!!".expandtabs()) # 输出：替换 \t 符号: this is string example....wow!!!print("使用16个空格替换 \\t 符号: " + "this is\tstring example....wow!!!".expandtabs(16)) # 输出：使用16个空格替换 \t 符号: this is string example....wow!!!# # decode(encoding="utf-8", errors="strict")：以指定的编码格式解码 bytes 对象，errors参数可以指定不同的错误处理方案，默认编码为 'utf-8'，该方法返回解码后的字符串# print("UTF-8 编码：", '雄雄雄'.encode('UTF-8')) # 输出：UTF-8 编码： b'\xe5\x8d\xa2\xe9\x9b\x84'# print("GBK 编码：", '雄雄雄'.encode('GBK')) # 输出：GBK 编码： b'\xc2\xac\xd0\xdb'# print("UTF-8 解码：", '雄雄雄'.encode('UTF-8').decode('UTF-8','strict')) # 输出：UTF-8 解码： 雄雄雄# print("GBK 解码：", '雄雄雄'.encode('GBK').decode('GBK','strict')) # 输出：GBK 解码： 雄雄雄# # encode(encoding='UTF-8',errors='strict')：以指定的编码格式编码字符串了，errors参数可以指定不同的错误处理方案，该方法返回编码后的字符串，它是一个 bytes 对象# print("UTF-8 编码：", '雄雄雄'.encode('UTF-8')) # 输出：UTF-8 编码： b'\xe5\x8d\xa2\xe9\x9b\x84'# print("GBK 编码：", '雄雄雄'.encode('GBK')) # 输出：GBK 编码： b'\xc2\xac\xd0\xdb'# print("UTF-8 解码：", '雄雄雄'.encode('UTF-8').decode('UTF-8', 'strict')) # 输出：UTF-8 解码： 雄雄雄# print("GBK 解码：", '雄雄雄'.encode('GBK').decode('GBK', 'strict')) # 输出：GBK 解码： 雄雄雄 List（列表）(1)List（列表）是Python中使用最频繁的数据类型，列表可以完成大多数集合类的数据结构实现(2)列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）(3)列表是写在方括号[]之间、用逗号分隔开的元素列表(4)和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表(5)加号+是列表连接运算符，星号*是重复操作 123456789101112131415&gt;&gt;&gt;list = [ 'abcd', 786 , 2.23, 'runoob', 70.2 ]&gt;&gt;&gt;tinylist = [123, 'runoob']&gt;&gt;&gt;print (list) # 输出完整列表['abcd', 786, 2.23, 'runoob', 70.2]&gt;&gt;&gt;print (list[0]) # 输出列表第一个元素abcd&gt;&gt;&gt;print (list[1:3]) # 从第二个开始输出到第三个元素[786, 2.23]&gt;&gt;&gt;print (list[2:]) # 输出从第三个元素开始的所有元素[2.23, 'runoob', 70.2]&gt;&gt;&gt;print (tinylist * 2) # 输出两次列表[123, 'runoob', 123, 'runoob']&gt;&gt;&gt;print (list + tinylist) # 连接列表['abcd', 786, 2.23, 'runoob', 70.2, 123, 'runoob'] (6)与Python字符串不一样的是，列表中的元素是可以改变的 12345678&gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6]&gt;&gt;&gt; a[0] = 9&gt;&gt;&gt; a[2:5] = [13, 14, 15]&gt;&gt;&gt; a[9, 2, 13, 14, 15, 6]&gt;&gt;&gt; a[2:5] = [] # 将对应的元素值设置为 [] &gt;&gt;&gt; a[9, 2, 6] (7)List内置了有很多方法，例如append()、pop()等等，这在后面会讲到 List写在方括号之间，元素用逗号隔开 和字符串一样，list可以被索引和切片 List可以使用+操作符进行拼接 List中的元素是可以改变的 (8)Python列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引1到索引4的位置并设置为步长为`2（间隔一个位置）来截取字符串(9)如果第三个参数为负数表示逆向读取，以下实例用于翻转字符串 1234567891011121314151617181920212223def reverseWords(input): # 通过空格将字符串分隔符，把各个单词分隔为列表 inputWords = input.split(" ") print(inputWords) # 输出：['I', 'like', 'runoob'] # 翻转字符串 # 假设列表 list = [1,2,3,4], # list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样) # inputWords[-1::-1] 有三个参数 # 第一个参数 -1 表示最后一个元素 # 第二个参数为空，表示移动到列表末尾 # 第三个参数为步长，-1 表示逆向 inputWords=inputWords[-1::-1] # 列表逆置 print(inputWords) # 重新组合字符串 output = ' '.join(inputWords) # 每个元素直接加个空格 return output if __name__ == "__main__": input = 'I like runoob' rw = reverseWords(input) print(rw) 输出结果为： 123['I', 'like', 'runoob']['runoob', 'like', 'I']runoob like I Python列表函数&amp;方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697# Python 列表testlist1 = ['Google', 'Runoob', 1997, 2000, 'Runoob']testlist2 = list('987123645')testlist3 = ['我最', '爱学习', 'python']# Python有6个序列的内置类型，但最常见的是列表和元组# 序列都可以进行的操作包括索引，切片，加，乘，检查成员print('testlist1：', testlist1) # testlist1： ['Google', 'Runoob', 1997, 2000]print('testlist2：', testlist2) # testlist2： ['1', '2', '3', '4', '5', '6', '7', '8', '9']testlist1[2] = 2001 # 更新testlist1第三个元素print('testlist1更新后的第三个元素为 :', testlist1[2]) # testlist1更新后的第三个元素为 : 2001del testlist1[2] # 删除testlist1第三个元素print('testlist1删除第三个元素后为 :', testlist1) # testlist1删除第三个元素后为 : ['Google', 'Runoob', 2000]# Python列表脚本操作符：列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表print('testlist2 长度为：', len(testlist2)) # testlist2 长度为： 9print('testlist1 和 testlist2 组合后为：', testlist1 + testlist2) # testlist1 和 testlist2 组合后为： ['Google', 'Runoob', 2000, '1', '2', '3', '4', '5', '6', '7', '8', '9']print('testlist1 重复输出3次：', testlist1 * 3) # testlist1 重复输出3次： ['Google', 'Runoob', 2000, 'Google', 'Runoob', 2000, 'Google', 'Runoob', 2000]print('3 是否在 testlist2中？', 3 in testlist2) # 3 是否在 testlist2中？ False# for x in testlist2:# print ('testlist2迭代：',x) # testlist2迭代： 1.....# Python列表函数&amp;方法# 函数# len(list)：返回列表元素个数print('range(5) 列表长度为：', len(range(5))) # range(5) 列表长度为： 5print('testlist2 列表长度为：', len(testlist2)) # testlist2 列表长度为： 9# max(list)：返回列表元素中的最大值# list元素全部为字符串类型(string)时，则比较的是比较的是每个字符串元素的第一个字符的 ASCII 的大小# list元素全部为数字类型时，直接根据值的大小比较# list元素为列表或者元组中的元素为数字类型和字符串类型混杂时，则无法比较print('testlist2 列表最大值为：', max(testlist2)) # testlist2 列表最大值为： 9print('testlist3 列表最大值为：', max(testlist3)) # testlist3 列表最大值为： 爱学习# min(list)：返回列表元素中的最小值print('testlist2 列表最大值为：', min(testlist2)) # testlist2 列表最大值为： 1print('testlist3 列表最大值为：', min(testlist3)) # testlist3 列表最大值为： python# list(seq)：将元组或字符串转换为列表print('该元组列表元素为：', list((123, 'Google', 'Runoob', 'Taobao'))) # 该元组列表元素为： [123, 'Google', 'Runoob', 'Taobao']print('range(5) 列表元素为：', list(range(5))) # range(5) 列表元素为： [0, 1, 2, 3, 4]# 方法# list.append(obj)：在列表末尾添加新的对象，该方法无返回值，但是会修改原来的列表testlist3.append('aaa')print('testlist3 更新后为：', testlist3) # testlist3 更新后为： ['我最', '爱学习', 'python', 'aaa']# list.count(obj)：用于统计某个元素在列表中出现的次数print('testlist1 中Runoob出现次数为：', testlist1.count('Runoob')) ## list.extend(seq)：在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）,seq-元素列表，可以是列表、元组、集合、字典，若为字典,则仅会将键(key)作为元素依次添加至原列表的末尾# 该方法没有返回值，但会在已存在的列表中添加新的列表内容testlist1.extend(testlist2)print('testlist1 和 testlist2 组合后为：', testlist1) # testlist1 和 testlist2 组合后为： ['Google', 'Runoob', 2000, 'Runoob', '1', '2', '3', '4', '5', '6', '7', '8', '9']# list.index(x[, start[, end]])：从列表中找出某个值第一个匹配项的索引位置，print('Taobao 索引值为：', ['Google', 'Runoob', 'Taobao'].index('Taobao')) # Taobao 索引值为 2# list.insert(index, obj)：用于将指定对象插入列表的指定位置# 该方法没有返回值，但会在列表指定位置插入对象testlist1.insert(1, 'Baidu')print('testlist1 插入元素后为：', testlist1) # testlist1 插入元素后为： ['Google', 'Baidu', 'Runoob', 2000, 'Runoob', '1', '2', '3', '4', '5', '6', '7', '8', '9']# ：移除列表中的一个元素（默认最后一个元素），并且返回该元素的值，索引值不能超过列表总长度，默认为 index=-1，删除最后一个列表值print('testlist1 移除的元素为：', testlist1.pop(1)) # testlist1 移除的元素为： Baidu# list.remove(obj)：移除列表中某个值的第一个匹配项# 该方法没有返回值但是会移除列表中的某个值的第一个匹配项testlist1.remove(2000)print('testlist1 更新后为：', testlist1) # testlist1 更新后为： ['Google', 'Runoob', 'Runoob', '1', '2', '3', '4', '5', '6', '7', '8', '9']# list.reverse()：用于反向列表中元# 该方法没有返回值，但是会对列表的元素进行反向排序testlist1.reverse()print('testlist1 反转后为：', testlist1) ## list.sort( key=None, reverse=False)：对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数# key -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序 reverse -- 排序规则，reverse = True 降序， reverse = False 升序（默认）# 该方法没有返回值，但是会对列表的对象进行排序testlist2.sort(reverse=True)print('testlist2 降序排列：', testlist2) # testlist2 降序排列： ['9', '8', '7', '6', '5', '4', '3', '2', '1']testlist2.sort()print('testlist2 升序排列：', testlist2) # testlist2 升序排列： ['1', '2', '3', '4', '5', '6', '7', '8', '9']def takeSecond(elem): # 获取列表的第二个元素 return elem[1]random = [(2, 2), (3, 4), (4, 1), (1, 3)] # 列表random.sort(key=takeSecond) # 指定第二个元素排序print('排序列表：', random) # 排序列表： [(4, 1), (2, 2), (1, 3), (3, 4)]# list.clear()：清空列表，类似于 del a[:]# 该方法没有返回值testlist1.clear()print('testlist1 列表清空后为：', testlist1) # testlist1 列表清空后为： []# list.copy()：用于复制列表，类似于 a[:]，返回复制后的新列表testlist4 = testlist2.copy()print('testlist2 后为：', testlist2) # testlist2 后为： ['1', '2', '3', '4', '5', '6', '7', '8', '9']print('testlist4 后为：', testlist4) # testlist4 后为： ['1', '2', '3', '4', '5', '6', '7', '8', '9'] Tuple（元组）(1)元组（tuple）与列表类似，不同之处在于元组的元素不能修改(2)元组写在小括号()里，元素之间用逗号隔开(3)元组中的元素类型也可以不相同(4)元组与字符串类似，可以被索引且下标索引从0开始，-1为从末尾开始的位置，也可以进行截取(字符串可以看作一种特殊的元组) 123456789&gt;&gt;&gt; tup = (1, 2, 3, 4, 5, 6)&gt;&gt;&gt; print(tup[0])1&gt;&gt;&gt; print(tup[1:5])(2, 3, 4, 5)&gt;&gt;&gt; tup[0] = 11 # 修改元组元素的操作是非法的Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'tuple' object does not support item assignment (5)tuple的元素不可改变，但它可以包含可变的对象，比如list列表(6)构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则 12tup1 = () # 空元组tup2 = (20,) # 一个元素，需要在元素后添加逗号 (7)string、list和tuple都属于sequence（序列） 与字符串一样，元组的元素不能修改 元组也可以被索引和切片，方法一样 注意构造包含 0 或 1 个元素的元组的特殊语法规则 元组也可以使用+操作符进行拼接 元组运算符与内置函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# 元组与列表类似，不同之处在于元组的元素不能修改# 元组使用小括号，列表使用方括号。元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可tup1 = ('Google', 'Runoob', 1997, 2000, 'Runoob')print('tup1：', tup1) # tup1： ('Google', 'Runoob', 1997, 2000, 'Runoob')tup2 = tuple('987123645')print('tup2：', tup2) # tup2： ('9', '8', '7', '1', '2', '3', '6', '4', '5')tup3 = "a", "b", "c", "d", "g", "f", "e", "h" # 不需要括号也可以print('tup3：', tup3) # tup3： ('a', 'b', 'c', 'd', 'g', 'f', 'e', 'h')tup4 = () # 创建空元组print('tup4：', tup4) # tup4： ()tup5 = 50, # 元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用print('tup5：', tup5) # tup5： (50,)# 元组中的元素值是不允许修改的，但我们可以对元组进行连接组合print('tup1 + tup2：', tup1 + tup2) # tup1 + tup2： ('Google', 'Runoob', 1997, 2000, 'Runoob', '9', '8', '7', '1', '2', '3', '6', '4', '5')# 元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组print('tup3[2] is：', tup3[2]) # tup3[2] is： c# del tup3 # 删除元组# print(tup3) # NameError: name 'tup' is not defined# 元组运算符：元组对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表print('tup2 长度为：', len(tup2)) # tup2 长度为： 9print('tup1 和 tup2 组合后为：', tup1 + tup2) # tup1 和 tup2 组合后为： ('Google', 'Runoob', 1997, 2000, 'Runoob', '9', '8', '7', '1', '2', '3', '6', '4', '5')print('tup1 重复输出3次：', tup1 * 3) # tup1 重复输出3次： ('Google', 'Runoob', 1997, 2000, 'Runoob', 'Google', 'Runoob', 1997, 2000, 'Runoob', 'Google', 'Runoob', 1997, 2000, 'Runoob')print('3 是否在 tup2中？', '3' in tup2) # 3 是否在 tup2中？ Truefor x in tup2: print('tup2迭代：', x) # tup2迭代： 9.....# 元组内置函数# len(tuple)：计算元组元素个数print('tup1 元素个数为：', len(tup1)) # tup1 元素个数为： 5# max(tuple)：返回元组中元素最大值# tuple元素全部为字符串类型(string)时，则比较的是比较的是每个字符串元素的第一个字符的 ASCII 的大小# tuple元素全部为数字类型时，直接根据值的大小比较# tuple元素为列表或者元组中的元素为数字类型和字符串类型混杂时，则无法比较print('tup2 最大值为：', max(tup2)) # tup2 最大值为： 9# min(tuple)：返回元组中元素最小值print('tup3 最小值为：', min(tup3)) # tup3 最小值为： a# tuple(iterable)：将可迭代系列转换为元组print('tup2 ：', tup2) # tup2 ： ('9', '8', '7', '1', '2', '3', '6', '4', '5')# 关于元组是不可变的：元组的不可变指的是元组所指向的内存中的内容不可变tup = ('r', 'u', 'n', 'o', 'o', 'b')print('tup：',tup) ## tup[0] = 'g' # 不支持修改元素，会报错：TypeError: 'tuple' object does not support item assignmentprint('查看内存地址：',id(tup)) # 查看内存地址： 2464144715208tup = (1,2,3) # 内存地址发生了改变print('查看内存地址：',id(tup)) # 查看内存地址： 2464146173240 Set（集合）(1)集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员(2)基本功能是进行成员关系测试和删除重复元素(3)可以使用大括号{ }或者set()函数创建集合，注意：创建一个空集合必须用set()而不是{ }，因为{ }是用来创建一个空字典 1234567891011121314151617sites = &#123;'Google', 'Taobao', 'Runoob', 'Facebook', 'Zhihu', 'Baidu', 'Google'&#125;print(sites) # 输出集合，重复的元素被自动去掉# 成员测试if 'Runoob' in sites : print('Runoob 在集合中')else : print('Runoob 不在集合中')# set可以进行集合运算a = set('abracadabra')b = set('alacazam')print('集合a为：',a,' 集合b为：',b)print(a - b) # a 和 b 的差集print(a | b) # a 和 b 的并集print(a &amp; b) # a 和 b 的交集print(a ^ b) # a 和 b 中不同时存在的元素 输出结果为： 1234567&#123;'Taobao', 'Google', 'Facebook', 'Runoob', 'Zhihu', 'Baidu'&#125;Runoob 在集合中集合a为： &#123;'b', 'a', 'd', 'r', 'c'&#125; 集合b为： &#123;'c', 'a', 'm', 'l', 'z'&#125;&#123;'b', 'r', 'd'&#125;&#123;'b', 'r', 'm', 'l', 'z', 'c', 'd', 'a'&#125;&#123;'c', 'a'&#125;&#123;'m', 'b', 'r', 'l', 'z', 'd'&#125; 集合的基本操作123456789101112131415161718192021222324252627282930313233# 集合（set）是一个无序的不重复元素序列# 创建集合set1 = &#123;'apple', 'orange', 'apple', 'pear', 'orange', 'banana'&#125; # 集合去重功能，去除重复的 apple ;快速判断元素是否在集合内print('set1：', set1) # set1： &#123;'pear', 'apple', 'banana', 'orange'&#125;print('orange 在 set1 内吗？：', 'orange' in set1) # orange 在 set1 内吗？： Trueset2 = set() # 创建空集合print('set2：', set2) # set2： set()# 集合的基本操作：添加元素add()、移除元素remove()、计算集合元素个数len()、清空集合clear()、判断元素是否在集合中存在 in # s.add( x )：将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作，该函数没有任何返回值set1.add(123)print('set1：', set1) # set1： &#123;'orange', 123, 'banana', 'pear', 'apple'&#125;# s.update( x )：添加元素，且参数可以是列表，元组，字典等，该函数没有任何返回值set1.update(['a','b','c'])print('set1：', set1) # set1： &#123;'orange', 'b', 'c', 'a', 'banana', 'pear', 'apple', 123&#125;# s.remove( x )：将元素 x 从集合 s 中移除，如果元素不存在，则会发生KeyError错误，该函数没有任何返回值set1.remove(123)print('set1：', set1) # set1： &#123;'pear', 'orange', 'c', 'banana', 'a', 'apple', 'b'&#125;# s.discard( x )：移除集合中的元素，且如果元素不存在，不会发生错误，该函数没有任何返回值set1.discard(246)print('set1：', set1) # set1： &#123;'pear', 'orange', 'c', 'banana', 'a', 'apple', 'b'&#125;# s.pop()：对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除并返回被删除的元素print('set1 移除的元素为：', set1.pop()) # set1 移除的元素为： banana# len(s)：计算集合 s 元素个数print('set1 的元素个数为：', len(set1)) # set1 的元素个数为： 6# s.clear()：清空集合 s，该函数没有任何返回值set1.clear()print('set1：', set1) # set1： set() 集合的内置方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# 创建集合set1 = &#123;'apple', 'orange', 'apple', 'pear', 'orange', 'banana'&#125; # 集合去重功能，去除重复的 apple ;快速判断元素是否在集合内print('set1：', set1) # set1： &#123;'pear', 'apple', 'banana', 'orange'&#125;print('orange 在 set1 内吗？：', 'orange' in set1) # orange 在 set1 内吗？： Trueset2 = set() # 创建空集合print('set2：', set2) # set2： set()# 集合内置方法# s.add( x )：将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作，该函数没有任何返回值set1.add(123)print('set1：', set1) # set1： &#123;'orange', 123, 'banana', 'pear', 'apple'&#125;# s.update( x )：添加元素，且参数可以是列表，元组，字典等，该函数没有任何返回值set1.update(['a','b','c'])print('set1：', set1) # set1： &#123;'orange', 'b', 'c', 'a', 'banana', 'pear', 'apple', 123&#125;# set.copy()：copy() 方法用于拷贝一个集合，该函数没有任何返回值set2=set1.copy()print('set2 拷贝 set1 为：', set2) # # x.difference(y)：difference() 方法用于返回集合的差集，即返回的集合元素包含在 x 中，但不包含在 y(方法的参数)中x = &#123;"apple", "banana", "cherry"&#125;y = &#123;"google", "microsoft", "apple"&#125;print('集合x和集合y的差集为：', x.difference(y)) # 集合x和集合y的差集为： &#123;'banana', 'cherry'&#125;print('集合x和集合y的差集为：', x - y) # 集合x和集合y的差集为： &#123;'banana', 'cherry'&#125;# x.difference_update(y)：在集合x中移除两个集合中都存在的元素，该函数没有任何返回值x.difference_update(y)print('集合 x 为：', x) # 集合 x 为： &#123;'banana', 'cherry'&#125;# set.union(set1, set2...)：返回两个或多个集合的并集，即包含了所有集合的元素，重复的元素只会出现一次x = set('abracadabra')y = set('alacazam')print('x 和 y 的并集为：', x.union(y)) # x 和 y 的并集为： &#123;'l', 'z', 'r', 'b', 'a', 'c', 'm', 'd'&#125;# set.intersection(set1, set2 ... etc)：返回两个或更多集合中都包含的元素，即交集print('集合x和集合y的交集为：', x.intersection(y)) # 集合x和集合y的交集为： &#123;'c', 'a'&#125;print('集合x和集合y的交集为：', x &amp; y) # 集合x和集合y的交集为： &#123;'c', 'a'&#125;# set.intersection_update(set1, set2 ... etc)：在集合x中保留所有集合的交集，该函数没有任何返回值x.intersection_update(y)print('集合 x 为：', x) # 集合 x 为： &#123;'a', 'c'&#125;# x.symmetric_difference(y)：返回两个集合中不重复的元素集合，即会移除两个集合中都存在的元素x = set('abracadabra')y = set('alacazam')print('集合x集合y中不同时存在的元素为：', x.symmetric_difference(y)) # 集合x集合y中不同时存在的元素为： &#123;'r', 'd', 'l', 'b', 'm', 'z'&#125;print('集合x集合y中不同时存在的元素为：', x ^ y) # 集合x集合y中不同时存在的元素为： &#123;'r', 'd', 'l', 'b', 'm', 'z'&#125;# x.symmetric_difference_update(y)：x集合中存放不重复的元素集合，该函数没有任何返回值x.symmetric_difference_update(y)print('集合 x 为：', x) # 集合 x 为： &#123;'l', 'r', 'd', 'b', 'm', 'z'&#125;# x.isdisjoint(y)：用于判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 Falsex = set('abracadabra')y = set('alacazam')print('集合x和集合y没有包含相同的元素？：', x.isdisjoint(y)) # 集合x和集合y没有包含相同的元素？： False# x.issubset(y)：判断集合x的所有元素是否都包含在指定集合y中(集合x是否是集合y的子集)，如果是则返回 True，否则返回 Falseprint('集合x是否是集合y的子集？：', x.issubset(y)) # 集合x是否是集合y的子集？： False# x.issuperset(y)：判断集合y的所有元素是否都包含在集合x中(集合y是否是集合x的子集)，如果是则返回 True，否则返回 Falseprint('集合x和集合y是否包含相同的元素？：', x.issuperset(y)) # 集合x和集合y是否包含相同的元素？： False# s.remove( x )：将元素 x 从集合 s 中移除，如果元素不存在，则会发生KeyError错误，该函数没有任何返回值set1.remove(123)print('set1：', set1) # set1： &#123;'pear', 'orange', 'c', 'banana', 'a', 'apple', 'b'&#125;# s.discard( x )：移除集合中的元素，且如果元素不存在，不会发生错误，该函数没有任何返回值set1.discard(246)print('set1：', set1) # set1： &#123;'pear', 'orange', 'c', 'banana', 'a', 'apple', 'b'&#125;# s.pop()：对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除并返回被删除的元素print('set1 移除的元素为：', set1.pop()) # set1 移除的元素为： banana# s.clear()：清空集合 s，该函数没有任何返回值set1.clear()print('set1：', set1) # set1： set() Dictionary（字典）(1)字典（dictionary）是Python中另一个非常有用的内置数据类型(2)列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取(3)字典是一种映射类型，字典用{ }标识，它是一个无序的键(key):值(value)的集合(4)键(key)必须使用不可变类型，在同一个字典中，键(key)必须是唯一的 1234567891011dict = &#123;&#125;dict['one'] = "1 - 菜鸟教程"dict[2] = "2 - 菜鸟工具"tinydict = &#123;'name': 'runoob','code':1, 'site': 'www.runoob.com'&#125;print (dict['one']) # 输出键为 'one' 的值print (dict[2]) # 输出键为 2 的值print (tinydict) # 输出完整的字典print (tinydict.keys()) # 输出所有键print (tinydict.values()) # 输出所有值 输出结果为： 123451 - 菜鸟教程2 - 菜鸟工具&#123;'name': 'runoob', 'code': 1, 'site': 'www.runoob.com'&#125;dict_keys(['name', 'code', 'site'])dict_values(['runoob', 1, 'www.runoob.com']) (5)构造函数dict()可以直接从键值对序列中构建字典如下： 123456&gt;&gt;&gt; dict([('Runoob', 1), ('Google', 2), ('Taobao', 3)])&#123;'Runoob': 1, 'Google': 2, 'Taobao': 3&#125;&gt;&gt;&gt; &#123;x: x**2 for x in (2, 4, 6)&#125;&#123;2: 4, 4: 16, 6: 36&#125;&gt;&gt;&gt; dict(Runoob=1, Google=2, Taobao=3)&#123;'Runoob': 1, 'Google': 2, 'Taobao': 3&#125; (6)字典类型也有一些内置的函数，例如clear()、keys()、values()等 字典是一种映射类型，它的元素是键值对 字典的关键字必须为不可变类型，且不能重复 创建空字典使用{ } 字典运算符与内置函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# 字典是另一种可变容器模型，且可存储任意类型对象# 字典的每个键值(key=&gt;value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号(&#123;&#125;)中# 键必须是唯一的，但值则不必。值可以取任何数据类型，但键必须是不可变的，如字符串，数字或字典# 创建字典dict1 = &#123;'Name': 'Runoob', 'Age': 7, 'Class': 'First'&#125; # 键值对创建字典print('dict1：', dict1) # dict1： &#123;'Name': 'Runoob', 'Age': 7, 'Class': 'First'&#125;print("dict1['Name']: ", dict1['Name'], "\tdict1['Class']: ", dict1['Class']) # dict1['Name']: Runoob dict1['Class']: Firstdict2 = dict([('Runoob', 1), ('Google', 2), ('Taobao', 3)]) # 构造函数 dict() 创建字典print('dict2：', dict2) # dict2： &#123;'Runoob': 1, 'Google': 2, 'Taobao': 3&#125;dict3 = dict(Runoob=1, Google=2, Taobao=3) # 构造函数 dict() 创建字典print('dict3：', dict3) # dict2： &#123;'Runoob': 1, 'Google': 2, 'Taobao': 3&#125;dict4 = &#123;x: x ** 2 for x in (2, 4, 6)&#125; #print('dict4：', dict4) # dict4： &#123;2: 4, 4: 16, 6: 36&#125;dict5 = &#123;&#125; # 创建空字典print('dict5：', dict5) # dict4： &#123;&#125;# 字典中的元素值是允许修改的，添加新内容的方法是增加新的键/值对，修改或删除已有键/值对dict1['Age'] = 8 # 更新 Agedict1['School'] = "清华大学" # 添加信息print('dict1：', dict1) # dict1： &#123;'School': '清华大学', 'Name': 'Runoob', 'Age': 8, 'Class': 'First'&#125;# 删除字典元素del dict1['Name'] # 删除键 'Name'print('dict1：', dict1) # dict1： &#123;'School': '清华大学', 'Age': 8, 'Class': 'First'&#125;dict1.clear() # 清空字典print('dict1：', dict1) # dict1： &#123;&#125;# del dict1 # 删除字典# print('dict1：', dict1) # 产生报错：NameError: name 'dict1' is not defined# 字典内置函数&amp;方法# 内置函数# len(dict)：计算字典元素个数，即键的总数print('dict2 长度为：', len(dict2)) # dict2 长度为： 3# str(dict)：输出字典，以可打印的字符串表示print('dict2 为：', str(dict2)) # dict2 为： &#123;'Taobao': 3, 'Runoob': 1, 'Google': 2&#125;# type(variable)：返回输入的变量类型，如果变量是字典就返回字典类型print('dict2 类型为：', type(dict2)) # dict2 类型为： &lt;class 'dict'&gt;# 内置方法# dict.clear()：clear() 函数用于删除字典内所有元素，该函数没有任何返回值dict3.clear()print('dict3 为：', str(dict3)) # dict3 为： &#123;&#125;# dict.copy()：copy() 函数返回一个字典的浅复制dict3 = dict2.copy()print('dict3 copy dict2 后为：', dict3) ## 直接赋值、浅拷贝和深度拷贝解析dic1 = &#123;'user': 'runoob', 'num': [1, 2, 3]&#125;dic2 = dic1 # 浅拷贝: 引用对象dic3 = dic1.copy() # 浅拷贝：深拷贝父对象（一级目录），子对象（二级目录）不拷贝，还是引用dic1['user'] = 'root' # 修改 dic1 数据dic1['num'].remove(1) # 修改 dic1 数据# dict2 其实是 dict1 的引用（别名），所以输出结果都是一致的，dict3 父对象进行了深拷贝，不会随dict1 修改而修改，子对象是浅拷贝所以随 dict1 的修改而修改print('dic1 为：', dic1) # dic1 为： &#123;'num': [2, 3], 'user': 'root'&#125;print('dic2 为：', dic2) # dic2 为： &#123;'num': [2, 3], 'user': 'root'&#125;print('dic3 为：', dic3) # dic3 为： &#123;'num': [2, 3], 'user': 'runoob'&#125;# dict.fromkeys(seq[, value])： fromkeys() 函数用于创建一个新字典，以序列 seq 中元素做字典的键，value 为字典所有键对应的初始值(默认为None)，该方法返回一个新字典print('dict 为：', dict.fromkeys(('k1', 'k2', 'k3'), 'a')) # dict 为： &#123;'k3': 'a', 'k2': 'a', 'k1': 'a'&#125;# dict.get(key, default=None)：get() 函数返回指定键的值，如果值不在字典中返回默认值(默认为None)print('dict2 的 Google 为：', dict2.get('Google')) # dict2 的 Google 为： 2# print('dict2 的 abc 为：', dict2['abc']) # abc对应的值不存在，返回错误：KeyError: 'abc'# key in dict：in 操作符用于判断键是否存在于字典中，如果键在字典 dict 里返回 true，否则返回 false，not in 操作符刚好相反print('Google 在 dict2 中：', 'Google' in dict2) # Google 在 dict2 中： True# dict.items()：items() 方法以列表返回可遍历的(键, 值) 元组数组print('dict2 为：', dict2.items()) ## dict.keys()：keys() 方法返回一个可迭代对象，可以使用 list() 来转换为列表print('dict2 的keys为：', dict2.keys()) # dict2 的keys为： dict_keys(['Runoob', 'Google', 'Taobao'])print('dict2 的keys为：', list(dict2.keys())) # dict2 的keys为： ['Runoob', 'Google', 'Taobao']# dict.values()：values() 方法返回一个迭代器，可以使用 list() 来转换为列表，列表为字典中的所有值print('dict2 的values为：', dict2.values()) # dict2 的values为： dict_values([2, 3, 1])print('dict2 的values为：', list(dict2.values())) # dict2 的values为： [2, 3, 1]# dict.setdefault(key, default=None)： setdefault() 方法和 get()方法 类似, 如果键(key)不已经存在于字典中，将会添加键并将值设为默认值(default),如果 key 在 字典中，返回对应的值print('dict2 的 Google 为：', dict2.setdefault('Google', 888)) # dict2 的 Google 为： 2print('dict2 的 abc 为：', dict2.setdefault('abc', 666)) # dict2 的 abc 为： 666# dict.pop(key[,default])： pop() 方法删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值，如key不存在且无default只，会报错KeyError: 3print('dict2 被删除的值为：', dict2.pop('Google', 888)) # dict2 被删除的值为： 2print('dict2 被删除的值为：', dict2.pop('abc', 666)) # dict2 被删除的值为： 666# dict.popitem()：popitem() 方法随机返回并删除字典中的最后一对键和值。返回一个键值对(key,value)形式，如果字典已经为空，却调用了此方法，就报出KeyError异常print('dict4 为：', dict4) # dict4 为： &#123;2: 4, 4: 16, 6: 36&#125;print('dict4 popitem 后为：', dict4.popitem()) # dict4 popitem 后为： (2, 4)print('dict4 为：', dict4) # dict4 为： &#123;4: 16, 6: 36&#125;# dict.update(dict2)： update() 函数把字典参数 dict2 的 key/value(键/值) 对更新到字典 dict 里，该方法没有任何返回值dict1 = &#123;'Name': 'Runoob', 'Age': 7&#125;dict2 = &#123;'Age': '88', 'School': '清华大学'&#125;dict1.update(dict2)print('dict1 更新后为：', dict1) # dict1 更新后为： &#123;'Name': 'Runoob', 'School': '清华大学', 'Age': '88'&#125; 直接赋值、浅拷贝和深度拷贝解析 Python数据类型转换(1)(2) 函数 | 描述 -- | :--: int(x [,base]) | 将 x 转换为一个整数(x为字符串或数字，base为进制数，默认十进制)float(x) | 将 x 转换到一个浮点数(x为整数或字符串)complex(real [,imag]) | 创建一个复数(real为int, long, float或字符串，imag为int, long, float)str(x) | 将对象 x 转换为字符串(x为object对象)repr(x) | 将对象 x 转换为表达式字符串(x为object对象)eval(str) | 用来计算在字符串中的有效Python字符串表达式,并返回一个对象tuple(s) | 将序列 s 转换为一个元组(s为要转换为元组的可迭代序列)list(s) | 将序列 s 转换为一个列表(s为要转换为列表的元组或字符串)set(s) | 转换为可变集合(s为要转换为元组的可迭代序列)dict(d) | 创建一个字典，d 必须是一个(key, value)元组序列frozenset(s) | 转换为不可变集合(s为可迭代序列，比如列表、字典、元组等等)chr(x) | 将一个整数转换为一个字符(x可以是10进制也可以是16进制的形式的整数，范围在0～255之内)ord(x) | 将一个字符转换为它的整数值(x为字符，返回对应的ASCII数值，或者Unicode数值)hex(x) | 将一个整数转换为一个十六进制字符串(x为10进制整数)oct(x) | 将一个整数转换为一个八进制字符串(x为整数)函数具体用法可参考：Python 内置函数 Python运算符优先级(1)(2) 运算符 | 描述 – | :–:** | 指数 (最高优先级)~ + - | 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) / % // | 乘，除，求余数和取整除 | 加法减法 &lt;&lt; | 右移，左移运算符&amp; | 位 ‘AND’^ | | 位运算符&lt;= &lt; &gt; &gt;= | 比较运算符== != | 等于运算符= %= /= //= -= += = *= | 赋值运算符is is not | 身份运算符in not in | 成员运算符not and or | 逻辑运算符]]></content>
      <categories>
        <category>Python</category>
        <category>Study</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3基础语法]]></title>
    <url>%2F2020%2F03%2F01%2Fpython%2Fpython01%2F</url>
    <content type="text"><![CDATA[前言:python学习第一章，简单介绍了python的一些基础语法… 编码(1)默认情况下，Python 3源码文件以UTF-8编码，所有字符串都是unicode字符串。 当然你也可以为源码文件指定不同的编码: 1# -*- coding: cp-1252 -*- 上述定义允许在源文件中使用 Windows-1252 字符集中的字符编码，对应适合语言为保加利亚语、白罗斯语、马其顿语、俄语、塞尔维亚语 Python 标识符(1)在 Python 里，标识符由字母、数字、下划线组成。(2)在 Python 中，所有标识符可以包括英文、数字以及下划线(_)，但不能以数字开头。(3)Python 中的标识符是区分大小写的。(4)以下划线开头的标识符是有特殊意义的。以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import *而导入。(5)以双下划线开头的 __foo 代表类的私有成员，以双下划线开头和结尾的 __foo__ 代表 Python 里特殊方法专用的标识，如 __init__() 代表类的构造函数。(6)Python 可以同一行显示多条语句，方法是用分号;分开，如： 123&gt;&gt;&gt; print ('hello');print ('runoob');hellorunoob Python 保留字符(1)python2保留字：下面的列表显示了在Python中的保留字。这些保留字不能用作常数或变数，或任何其他标识符名称。所有 Python 的关键字只包含小写字母and | exec | not – | :–: | –:assert | finally | orbreak | for | passclass | from | printcontinue| global | raisedef | if | returndel | import | tryelif | in | whileelse | is | withexcept | lambda | yield(2)python3保留字： 123&gt;&gt;&gt; import keyword&gt;&gt;&gt; keyword.kwlist['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 行和缩进(1)Python 的代码块不使用大括号{}来控制类，函数以及其他逻辑判断(2)python 最具特色的就是用缩进来写模块(3)缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行 正确写法： 1234if True: print ("True")else: print ("False") 错误写法： 1234567if True: print ("Answer") print ("True")else: print ("Answer") # 采用空格缩进 # 没有严格缩进，在执行时会报错:IndentationError: unindent does not match any outer indentation level print ("False") # 采用tab缩进 (4)IndentationError: unindent does not match any outer indentation level错误表明，你使用的缩进方式不一致，有的是tab键缩进，有的是空格缩进，改为一致即可(5)如果是IndentationError: unexpected indent错误, 则 python 编译器是在告诉你”Hi，老兄，你的文件里格式不对了，可能是tab和空格没对齐的问题”，所有 python 对格式要求非常严格。(6)在 Python 的代码块中必须使用相同数目的行首缩进空格数。 注：建议在每个缩进层次使用 单个制表符 或 两个空格 或 四个空格 , 切记不能混用 多行语句(1)Python语句中一般以新行作为语句的结束符，但是我们可以使用斜杠（ \）将一行的语句分为多行显示： 12345&gt;&gt;&gt; total = 'item_one' + \... 'item_two' + \... 'item_three'&gt;&gt;&gt; print(total)item_oneitem_twoitem_three (2)语句中包含[],{}或()括号就不需要使用多行连接符。如下实例： 1234&gt;&gt;&gt; days = ['Monday', 'Tuesday', 'Wednesday',... 'Thursday', 'Friday']&gt;&gt;&gt; print(days)['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'] Python 引号(1)Python 可以使用引号(&#39;)、双引号(&quot;)、三引号(&#39;&#39;&#39;或&quot;&quot;&quot;) 来表示字符串，引号的开始与结束必须是相同类型的(2)其中三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释 123456789&gt;&gt;&gt; word = 'word'&gt;&gt;&gt; sentence = "这是一个句子。"&gt;&gt;&gt; paragraph = '''这是一个段落。... 包含了多个语句'''&gt;&gt;&gt; print(word+'\n'+sentence+'\n'+paragraph)word这是一个句子。这是一个段落。包含了多个语句 Python 注释(1)单行注释 12# 第一个注释print ("Hello, Python!") # 第二个注释 (2)多行注释 1234567891011'''这是多行注释，使用单引号。这是多行注释，使用单引号。这是多行注释，使用单引号。'''"""这是多行注释，使用双引号。这是多行注释，使用双引号。这是多行注释，使用双引号。""" Python 同一行显示多条语句(1)Python可以在同一行中使用多条语句，语句之间使用分号;分割，以下是一个简单的实例： 123&gt;&gt;&gt; import sys; x = 'runoob'; sys.stdout.write(x + '\n')runoob7 print 输出函数(1)print 默认输出是换行的，如果要实现不换行需要在变量末尾加上逗号, 12345678910111213x="a"y="b"# 换行输出print (x)print (y)print ('---------')# 不换行输出print (x,)print (y,)# 不换行输出print (x,y) 输出结果： 123456ab---------aba b python 3.x 的需要要加括号，写成print()的格式 多个语句构成代码组(1)缩进相同的一组语句构成一个代码块，我们称之代码组(2)像if、while、def和class这样的复合语句，首行以关键字开始，以冒号:结束，该行之后的一行或多行代码构成代码组(3)我们将首行及后面的代码组称为一个子句(clause) 1234567891011x=input("请输入一个整数：") #输入6x = int(x)y=input("请输入一个整数：") #输入8y=int(y)if x==y : print('x=y')elif x&gt;y : print('x&gt;y')else : print('x&lt;y') 输出结果： 1x&lt;y import 与 from…import(1)在python用import或者from...import来导入相应的模块(2)将整个模块(somemodule)导入，格式为：import somemodule(3)从某个模块中导入某个函数,格式为：from somemodule import somefunction(4)从某个模块中导入多个函数,格式为：from somemodule import firstfunc, secondfunc, thirdfunc(5)将某个模块中的全部函数导入，格式为：from somemodule import * 导入sys模块 123456import sysprint('================Python import mode==========================')print ('命令行参数为:')for i in sys.argv: print (i)print ('\n python 路径为',sys.path) 导入sys模块的argv,path成员 1234from sys import argv,path # 导入特定的成员 print('================python from import===================================')print('path:',path) # 因为已经导入path成员，所以此处引用时不需要加sys.path end 关键字关键字end可以用于将结果输出到同一行，或者在输出的末尾添加不同的字符 123456a, b, count = 0, 1, 0while b &lt; 10: count+=1 print('第 ',count,' 次遍历:',end=',') print(b) a, b = b, a+b 输出结果： 123456第 1 次遍历:,1第 2 次遍历:,1第 3 次遍历:,2第 4 次遍历:,3第 5 次遍历:,5第 6 次遍历:,8 Python 基础语法图]]></content>
      <categories>
        <category>Python</category>
        <category>Study</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN提交报错“Empty directories is not supported”]]></title>
    <url>%2F2020%2F02%2F25%2Fstudy%2Fsvn-Empty%2F</url>
    <content type="text"><![CDATA[前言:svn 文件夹空 提交报错“Empty directories is not supported: /.git/objects/info” 解决方案 一级标题下载jar包参考链接：https://blog.csdn.net/qq_39816586/article/details/88634216下载链接: https://pan.baidu.com/s/17uc7lQ2xS-MzljIkOwu_Rg 提取码: w8pk]]></content>
      <categories>
        <category>实用技术</category>
        <category>SVN</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QC问题流程梳理]]></title>
    <url>%2F2019%2F09%2F04%2Fweaver%2Fquestion-tidy%2F</url>
    <content type="text"><![CDATA[这篇文章是私人的哦，输下密码吧(*๓´╰╯`๓) Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>weaver</category>
      </categories>
      <tags>
        <tag>weaver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle常用视图]]></title>
    <url>%2F2019%2F05%2F19%2Fdatabase%2Foracle-views%2F</url>
    <content type="text"><![CDATA[前言:本文主要介绍的是Oracle常用的一些视图，包括：v$session、v$sql、v$sqlarea，后期继续补充… v$session使用示例v$session主要是查看当前服务器所有session信息 1select sid, serial#, status, username, program, machine, osuser, logon_time from v$session; 常用字段列名解析：12345678910111213141516171819-- status：这列用来判断session状态，取值为：Achtive、Inactive、killed-- Achtive： 正执行SQL语句(waiting for/using a resource)-- Inactive： 等待操作(即等待需要执行的SQL语句)-- Killed： 被标注为删除-- session信息-- sid: SESSION标识，常用于连接其它列-- SERIAL#： 如果某个SID又被其它的session使用的话则此数值自增加(当一个SESSION结束，另一个SESSION开始并使用了同一个SID)-- AUDSID： 审查session ID唯一性，确认它通常也用于当寻找并行查询模式-- USERNAME：当前session在oracle中的用户名-- client信息-- OSUSER： 客户端操作系统用户名-- MACHINE： 客户端执行的机器-- TERMINAL： 客户端运行的终端-- PROCESS： 客户端进程的ID-- PROGRAM： 客户端执行的客户端程序-- Application信息-- CLIENT_INFO： DBMS_APPLICATION_INFO中设置-- ACTION： DBMS_APPLICATION_INFO中设置-- MODULE： DBMS_APPLICATION_INFO中设置 v$sql使用示例v$sql主要是用来分析SQL语句使用资源情况 1SELECT * FROM v$sql WHERE sql_fulltest LIKE '%2019-08-21%'; 常用字段列名解析：1234567891011121314151617181920212223242526272829303132333435-- SQL_TEXT //当前正在执行的游标的sql文本的前1000个字符-- SQL_FULLTEXT //CLOB类型 整个sql文本，不用借助于V$SQL_TEXT视图来查看整个文本-- SQL_ID //库缓存中的SQL父游标的标志-- SHARABLE_MEM //子游标使用的共享内存的大小,bytes-- PERSISTENT_MEM //子游标生存时间中使用的固定内存的总量,bytes-- RUNTIME_MEM //在子游标执行过程中需要的固定内存大小，bytes-- SORTS //子游标发生的排序数量-- LOADED_VERSIONS // 显示上下文堆是否载入，1是，0否-- USERS_OPENING // 执行这个sql的用户数-- FETCHES // sql取数据的次数-- EXECUTIONS //自从被载入共享池后，sql执行的次数 -- FIRST_LOAD_TIME // 父游标产生的时间戳-- PARSE_CALLS //解析调用的次数 -- DISK_CALLS //读磁盘的次数-- DIRECT_WRITES //直接写的次数-- BUFFER_GETS //直接从buffer中得到数据的次数-- APPLICATION_WAIT_TIME // 应用等待时间，毫秒-- CONCURRENCY_WAIT_TIME //并发等待时间，毫秒-- USER_IO_WAIT_TIME //用户IO等待时间-- ROWS_PROCESSED SQL //解析sql返回的总行数-- OPTIMIZER_MODE //优化器模式-- OPTIMIZER_COST //优化器对于sql给出的成本-- PARSING_USER_ID //第一个创建这个子游标的用户id-- HASH_VALUES //解析产生的哈希值-- CHILD_NUMBER //该子游标的数量-- SERVICE //服务名-- CPU_TIME //该子游标解析，执行和获取数据使用的CPU时间，毫秒-- ELAPSED_TIME //sql的执行时间，毫秒-- INVALIDATIONS //该子游标的无效次数-- MODULE //第一次解析该语句时,通过DBMS_APPLICAITON_INFO.SET_ACTION设置的模块名-- ACTION //第一次解析该语句时,通过DBMS_APPLICAITON_INFO.SET_ACTION设置的动作名 -- IS_OBSOLETE //标记该子游标过期与否，当子游标过大时会发生这种情况-- is_bind_sensitive //不仅指出是否使用绑定变量窥测来生成执行计划，而且指出这个执行计划是否依赖于窥测到的值。如果是，这个字段会被设置为Y，否则会被设置为N。-- is_bind_aware //表明游标是否使用了扩展的游标共享。如果是，这个字段会被设置为Y，如果不是，这个字段会被设置为N。如果是设置为N，这个游标将被废弃，不再可用。-- is_shareable //表明游标能否被共享。如果可以，这个字段会被设置为Y，否则，会被设置为N。如果被设置为N，这个游标将被废弃，不再可用。 v$sqlarea使用示例v$sqlarea和v$sql基本一致，不同的是V$SQLAREA是在父游标级别上统计的sql信息，v$sql的汇总表，进行了group by hash_value,sql_id的汇总 1select * from v$sqlarea WHERE sql_fulltest LIKE '%2019-08-21%';]]></content>
      <categories>
        <category>Database</category>
        <category>view</category>
      </categories>
      <tags>
        <tag>Database</tag>
        <tag>SQL</tag>
        <tag>view</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于索引的sql语句优化之降龙十八掌]]></title>
    <url>%2F2019%2F04%2F18%2Fdatabase%2Fdb-index%2F</url>
    <content type="text"><![CDATA[前言:本文主要介绍了基于索引的SQL语句优化的降龙十八掌 前言在规模比较大的局点，往往因为一个小的SQL语句不够优化，导致数据库性能急剧下降，小型机idle所剩无几，应用服务器断连、超时，严重影响业务的正常运行。因此，称低效的SQL语句为业务的‘恶龙’并不过分。数据库的优化方法有很多种，在应用层来说，主要是基于索引的优化。本次秘笈根据实际的工作经验，在研发原来已有的方法的基础上，进行了一些扩充，总结了基于索引的SQL语句优化的降龙十八掌，希望有一天你能用其中一掌来驯服业务中横行的‘恶龙’。 总纲——建立必要的索引降龙十八掌，总纲只有一句话：建立必要的索引，这就是后面降龙十八掌的内功基础。这一点看似容易实际却很难。难就难在如何判断哪些索引是必要的，哪些又是不必要的。判断的最终标准是看这些索引是否对我们的数据库性能有所帮助。具体到方法上，就必须熟悉数据库应用程序中的所有SQL语句，从中统计出常用的可能对性能有影响的部分SQL，分析、归纳出作为Where条件子句的字段及其组合方式；在这一基础上可以初步判断出哪些表的哪些字段应该建立索引。其次，必须熟悉应用程序。必须了解哪些表是数据操作频繁的表；哪些表经常与其他表进行连接；哪些表中的数据量可能很大；对于数据量大的表，其中各个字段的数据分布情况如何；等等。对于满足以上条件的这些表，必须重点关注，因为在这些表上的索引，将对SQL语句的性能产生举足轻重的影响。不过下面还是总结了一下降龙十八掌内功的入门基础，建立索引常用的规则如下：(1) 表的主键、外键必须有索引；(2) 数据量超过300的表应该有索引；(3) 经常与其他表进行连接的表，在连接字段上应该建立索引；(4) 经常出现在where子句中的字段，特别是大表的字段，应该建立索引；(5) 索引应该建在选择性高的字段上；(6) 索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；(7) 复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替： 正确选择复合索引中的主列字段，一般是选择性较好的字段； 复合索引的几个字段是否经常同时以AND方式出现在where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引； 如果复合索引中包含的字段经常单独出现在where子句中，则分解为多个单字段索引； 如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段； 如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引； (8) 频繁进行数据操作的表，不要建立太多的索引；(9) 删除无用的索引，避免对执行计划造成负面影响； 以上是一些普遍的建立索引时的判断依据。一言以蔽之，索引的建立必须慎重，对每个索引的必要性都应该经过仔细分析，要有建立的依据。因为太多的索引与不充分、不正确的索引对性能都毫无益处：在表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。 降龙十八掌第一掌 避免对列的操作任何对列的操作都可能导致全表扫描，这里所谓的操作包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等式的右边，甚至去掉函数。例1：下列SQL条件语句中的列都建有恰当的索引，但 30万行数据情况下执行速度却非常慢： 123select * from record where substrb(CardNo,1,4)='5378'(13秒) select * from record where amount/30&lt; 1000（11秒） select * from record where to_char(ActionTime,'yyyymmdd')='19991201'（10秒） 由于where子句中对列的任何操作结果都是在SQL运行时逐行计算得到的，因此它不得不进行表扫描，而没有使用该列上面的索引；如果这些结果在查询编译时就能得到，那么就可以被SQL优化器优化，使用索引，避免表扫描，因此将SQL重写如下： 1234select * from record where CardNo like '5378%'（&lt; 1秒） select * from record where amount &lt; 1000*30（&lt; 1秒） select * from record where ActionTime= to_date ('19991201' ,'yyyymmdd')（&lt; 1秒） 差别是很明显的！ 第二掌 避免不必要的类型转换需要注意的是，尽量避免潜在的数据类型转换。如将字符型数据与数值型数据比较，ORACLE会自动将字符型用to_number()函数进行转换，从而导致全表扫描。例2：表tab1中的列col1是字符型(char)，则以下语句存在类型转换： 1select col1,col2 from tab1 where col1&gt;10 应该写为： 1select col1,col2 from tab1 where col1&gt;'10' 第三掌 增加查询的范围限制增加查询的范围限制，避免全范围的搜索。例3：以下查询表record中时间ActionTime小于2001年3月1日的数据： 1select * from record where ActionTime &lt; to_date ('20010301' ,'yyyymm') 查询计划表明，上面的查询对表进行全表扫描，如果我们知道表中的最早的数据为2001年1月1日，那么，可以增加一个最小时间，使查询在一个完整的范围之内。修改如下： 1select * from record where ActionTime &lt; to_date ('20010301' ,'yyyymm') and ActionTime &gt; to_date ('20010101' ,'yyyymm') 后一种SQL语句将利用上ActionTime字段上的索引，从而提高查询效率。把20010301换成一个变量，根据取值的机率，可以有一半以上的机会提高效率。同理，对于大于某个值的查询，如果知道当前可能的最大值，也可以在Where子句中加上“AND 列名&lt; MAX(最大值)”。 第四掌 尽量去掉”IN”、”OR”含有”IN“、”OR“的where子句常会使用工作表，使索引失效；如果不产生大量重复值，可以考虑把子句拆开；拆开的子句中应该包含索引。例4： 1select count(*) from stuff where id_no in('0','1')（23秒） 可以考虑将or子句分开： 12select count(*) from stuff where id_no='0' select count(*) from stuff where id_no='1' 然后再做一个简单的加法，与原来的SQL语句相比，查询速度更快。 第五掌 尽量去掉 “&lt;&gt;”尽量去掉 “&lt;&gt;“，避免全表扫描，如果数据是枚举值，且取值范围固定，则修改为”OR“方式。例5： 1UPDATE SERVICEINFO SET STATE=0 WHERE STATE&lt;&gt;0; 以上语句由于其中包含了”&lt;&gt;“，执行计划中用了全表扫描(TABLE ACCESS FULL)，没有用到state字段上的索引。实际应用中，由于业务逻辑的限制，字段state为枚举值，只能等于0，1或2，而且，值等于=1，2的很少，因此可以去掉”&lt;&gt;“，利用索引来提高效率。 修改为： 1UPDATE SERVICEINFO SET STATE=0 WHERE STATE = 1 OR STATE = 2; 进一步的修改可以参考第4种方法。 第六掌 去掉Where子句中的IS NULL和IS NOT NULLwhere子句中的IS NULL和IS NOT NULL将不会使用索引而是进行全表搜索，因此需要通过改变查询方式，分情况讨论等方法，去掉where子句中的IS NULL和IS NOT NULL。 第七掌 索引提高数据分布不均匀时查询效率索引的选择性低，但数据的值分布差异很大时，仍然可以利用索引提高效率。A、数据分布不均匀的特殊情况下，选择性不高的索引也要创建。表ServiceInfo中数据量很大，假设有一百万行，其中有一个字段DisposalCourseFlag，取值范围为枚举值：[0，1，2，3，4，5，6，7]按照前面说的索引建立的规则，“选择性不高的字段不应该建立索引，该字段只有8种取值，索引值的重复率很高，索引选择性明显很低，因此不建索引。然而，由于该字段上数据值的分布情况非常特殊，具体如下表：取值范围:1~5 6 7 占总数据量的百分比:1% 98% 1%而且，常用的查询中，查询DisposalCourseFlag&lt;6的情况既多又频繁，毫无疑问，如果能够建立索引，并且被应用，那么将大大提高这种情况的查询效率。因此，我们需要在该字段上建立索引。 第八掌 利用HINT强制指定索引在ORACLE优化器无法用上合理索引的情况下，利用HINT强制指定索引。继续上面7的例子，ORACLE缺省认定，表中列的值是在所有数据行中均匀分布的，也就是说，在一百万数据量下，每种DisposalCourseFlag值各有12.5万数据行与之对应。假设SQL搜索条件DisposalCourseFlag=2，利用DisposalCourseFlag列上的索引进行数据搜索效率，往往不比全表扫描的高，ORACLE因此对索引“视而不见”，从而在查询路径的选择中，用其他字段上的索引甚至全表扫描。根据我们上面的分析，数据值的分布很特殊，严重的不均匀。为了利用索引提高效率，此时，一方面可以单独对该字段或该表用analyze语句进行分析，对该列搜集足够的统计数据，使ORACLE在查询选择性较高的值时能用上索引；另一方面，可以利用HINT提示，在SELECT关键字后面，加上“/*+ INDEX(表名称，索引名称）*/”的方式，强制ORACLE优化器用上该索引。 比如： 1select * from serviceinfo where DisposalCourseFlag=1 ; 上面的语句，实际执行中ORACLE用了全表扫描，加上蓝色提示部分后，用到索引查询。如下： 1select /*+ INDEX(SERVICEINFO,IX_S_DISPOSALCOURSEFLAG) */ * from serviceinfo where DisposalCourseFlag=1; 请注意，这种方法会加大代码维护的难度，而且该字段上索引的名称被改变之后，必须要同步所有指定索引的HINT代码，否则HINT提示将被ORACLE忽略掉。 第九掌 屏蔽无用索引继续上面8的例子，由于实际查询中，还有涉及到DisposalCourseFlag=6的查询，而此时如果用上该字段上的索引，将是非常不明智的，效率也极低。因此这种情况下，我们需要用特殊的方法屏蔽该索引，以便ORACLE选择其他字段上的索引。比如，如果字段为数值型的就在表达式的字段名后，添加“+ 0”，为字符型的就并上空串：“||&quot;&quot;” 如： 1select * from serviceinfo where DisposalCourseFlag+ 0 = 6 and workNo = '36' 不过，不要把该用的索引屏蔽掉了，否则同样会产生低效率的全表扫描。 第十掌 分解复杂查询，用常量代替变量对于复杂的Where条件组合，where中含有多个带索引的字段，考虑用IF语句分情况进行讨论；同时，去掉不必要的外来参数条件，减低复杂度，以便在不同情况下用不同字段上的索引。 继续上面9的例子，对于包含 1where (DisposalCourseFlag &lt; v_DisPosalCourseFlag) or (v_DisPosalCourseFlag is null) and.... 的查询，(这里v_DisPosalCourseFlag为一个输入变量，取值范围可能为[NULL，0，1，2，3，4，5，6，7])，可以考虑分情况用IF语句进行讨论，类似： 1234567IF v_DisPosalCourseFlag =1 THEN Where DisposalCourseFlag = 1 and .... ELSIF v_DisPosalCourseFlag =2 THEN Where DisposalCourseFlag = 2 and ....``` #### 第十一掌 like子句尽量前端匹配 因为like参数使用的非常频繁，因此如果能够对like子句使用索引，将很高的提高查询的效率。 *例6*： select * from city where name like ‘%S%’ 1以上查询的执行计划用了全表扫描（TABLE ACCESS FULL），如果能够修改为： select * from city where name like ‘S%’ 1234567那么查询的执行计划将会变成（`INDEX RANGE SCAN`），成功的利用了`name`字段的索引。这意味着Oracle SQL优化器会识别出用于索引的like子句，只要该查询的匹配端是具体值。因此我们在做like查询时，应该尽量使查询的匹配端是具体值，即使用`like ‘S%’`。#### 第十二掌 用Case语句合并多重扫描 我们常常必须基于多组数据表计算不同的聚集。例如下例通过三个独立查询： *例8*：1） select count() from emp where sal&lt;1000;select count() from emp where sal between 1000 and 5000;select count(*) from emp where sal&gt;5000; 1这样我们需要进行三次全表查询，但是如果我们使用case语句： select count (sale when sal &lt;1000 then 1 else null end) count_poor, count (sale when between 1000 and 5000 then 1 else null end) count_blue_collar, count (sale when sal &gt;5000 then 1 else null end) count_poor from emp; 12345这样查询的结果一样，但是执行计划只进行了一次全表查询。#### 第十三掌 使用nls_date_format *例9*： select * from record where to_char(ActionTime,’mm’)=’12’ 1这个查询的执行计划将是全表查询，如果我们改变`nls_date_format， SQL&gt;alert session set nls_date_formate=’MM’;`现在重新修改上面的查询： select * from record where ActionTime=’12’ 12345这样就能使用`actiontime`上的索引了，它的执行计划将是（`INDEX RANGE SCAN`）。#### 第十四掌 使用基于函数的索引 前面谈到任何对列的操作都可能导致全表扫描，例如： select * from emp where substr(ename,1,2)=’SM’; 1但是这种查询在客服系统又经常使用，我们可以创建一个带有substr函数的基于函数的索引， create index emp_ename_substr on eemp ( substr(ename,1,2) ); 12345这样在执行上面的查询语句时，这个基于函数的索引将排上用场，执行计划将是（`INDEX RANGE SCAN`）。#### 第十五掌 基于函数的索引要求等式匹配 上面的例子中，我们创建了基于函数的索引，但是如果执行下面的查询： select * from emp where substr(ename,1,1)=’S’```得到的执行计划将还是（TABLE ACCESS FULL），因为只有当数据列能够等式匹配时，基于函数的索引才能生效，这样对于这种索引的计划和维护的要求都很高。请注意，向表中添加索引是非常危险的操作，因为这将导致许多查询执行计划的变更。然而，如果我们使用基于函数的索引就不会产生这样的问题，因为Oracle只有在查询使用了匹配的内置函数时才会使用这种类型的索引。 第十六掌 使用分区索引在用分析命令对分区索引进行分析时，每一个分区的数据值的范围信息会放入Oracle的数据字典中。Oracle可以利用这个信息来提取出那些只与SQL查询相关的数据分区。例如，假设你已经定义了一个分区索引，并且某个SQL语句需要在一个索引分区中进行一次索引扫描。Oracle会仅仅访问这个索引分区，而且会在这个分区上调用一个此索引范围的快速全扫描。因为不需要访问整个索引，所以提高了查询的速度。 第十七掌 使用位图索引位图索引可以从本质上提高使用了小于1000个唯一数据值的数据列的查询速度，因为在位图索引中进行的检索是在RAM中完成的，而且也总是比传统的B树索引的速度要快。对于那些少于1000个唯一数据值的数据列建立位图索引，可以使执行效率更快。 第十八掌 决定使用全表扫描还是使用索引和所有的秘笈一样，最后一招都会又回到起点，最后我们来讨论一下是否需要建立索引，也许进行全表扫描更快。在大多数情况下，全表扫描可能会导致更多的物理磁盘输入输出，但是全表扫描有时又可能会因为高度并行化的存在而执行的更快。如果查询的表完全没有顺序，那么一个要返回记录数小于10％的查询可能会读取表中大部分的数据块，这样使用索引会使查询效率提高很多。但是如果表非常有顺序，那么如果查询的记录数大于40％时，可能使用全表扫描更快。因此，有一个索引范围扫描的总体原则是：1) 对于原始排序的表:仅读取少于表记录数40％的查询应该使用索引范围扫描。反之，读取记录数目多于表记录数的40％的查询应该使用全表扫描。2) 对于未排序的表:仅读取少于表记录数7％的查询应该使用索引范围扫描。反之，读取记录数目多于表记录数的7％的查询应该使用全表扫描。 总结以上的招式，是完全可以相互结合同时运用的。而且各种方法之间相互影响，紧密联系。这种联系既存在一致性，也可能带来冲突，当冲突发生时，需要根据实际情况进行选择，没有固定的模式。最后决定SQL优化功力的因素就是对ORACLE内功的掌握程度了。另外，值得注意的是：随着时间的推移和数据的累计与变化，ORACLE对SQL语句的执行计划也会改变，比如：基于代价的优化方法，随着数据量的增大，优化器可能错误的不选择索引而采用全表扫描。这种情况可能是因为统计信息已经过时，在数据量变化很大后没有及时分析表；但如果对表进行分析之后，仍然没有用上合理的索引，那么就有必要对SQL语句用HINT提示，强制用合理的索引。但这种HINT提示也不能滥用，因为这种方法过于复杂，缺乏通用性和应变能力，同时也增加了维护上的代价；相对来说，基于函数右移、去掉“IN ，OR ，&lt;&gt; ，IS NOT NULL ”、分解复杂的SQL语句等等方法，却是“放之四海皆准”的，可以放心大胆的使用。同时，优化也不是“一劳永逸”的，必须随着情况的改变进行相应的调整。当数据库设计发生变化，包括更改表结构：字段和索引的增加、删除或改名等；业务逻辑发生变化：如查询方式、取值范围发生改变等等。在这种情况下，也必须对原有的优化进行调整，以适应效率上的需求。]]></content>
      <categories>
        <category>Database</category>
        <category>index</category>
      </categories>
      <tags>
        <tag>Database</tag>
        <tag>SQL</tag>
        <tag>index</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome浏览器中F12功能的简单介绍]]></title>
    <url>%2F2019%2F03%2F18%2Fstudy%2Fchrome-F12%2F</url>
    <content type="text"><![CDATA[前言:Chrome浏览器F12开发者工具开发人员的利器,查看了一些博客和资料，简单总结一下~ 常用页面Chrome开发者工具中，调试时使用最多的三个功能页面是：元素（ELements）、控制台（Console）、源代码（Sources），此外还有网络（Network）等 元素（Elements）：用于查看或修改HTML元素的属性、CSS属性、监听事件、断点等。 控制台（Console）：控制台一般用于执行一次性代码，查看JavaScript对象，查看调试日志信息或异常信息。 源代码（Sources）：该页面用于查看页面的HTML文件源代码、JavaScript源代码、CSS源代码，此外最重要的是可以调试JavaScript源代码，可以给JS代码添加断点等。 网络（Network）：网络页面主要用于查看header等与网络连接相关的信息。 元素（Elements） 查看元素代码：点击如图箭头（或用者用快捷键Ctrl+Shift+C）进入选择元素模式，然后从页面中选择需要查看的元素，然后可以在开发者工具元素（Elements）一栏中定位到该元素源代码的具体位置： 查看元素属性：可从被定位的源码中查看部分，如class、src，也可在右边的侧栏中查看全部的属性，如下图位置查看： 修改元素的代码与属性：可直接双击想要修改的部分，然后就进行修改，或者选中要修改部分后点击右键进行修改，如下图： 注意：这个修改也仅对当前的页面渲染生效，不会修改服务器的源代码，故而这个功能也是作为调试页面效果而使用 右边的侧栏个功能的介绍:如下图所示 控制台（Console） 查看JS对象的及其属性 执行JS语句 查看控制台日志：当网页的JS代码中使用了console.log()函数时，该函数输出的日志信息会在控制台中显示。日志信息一般在开发调试时启用，而当正式上线后，一般会将该函数去掉。 源代码（Sources）其主要功能如下介绍: 网络（Network） 主要功能如下： 请求文件具体说明： 分为四个模块： Header：面板列出资源的请求url、HTTP方法、响应状态码、请求头和响应头及它们各自的值、请求参数等等 Preview：预览面板，用于资源的预览。 Response：响应信息面板包含资源还未进行格式处理的内容 Timing：资源请求的详细信息花费时间 小技巧只分析异步请求资源【Network】下面点击“XHR”，这样就只会显示XHR异步请求资源，以便于快速分析请求Headers和Response 快速查找并定位文件 查看源代码，鼠标移到开发工具窗口，按ctrl+p，输入链接地址的前几个字母，会自动联想显示所有符合条件的地址，点击打开即可。（有时第一次打开是空白内容，可再点击一次链接） 打开之后，如果是js内容，就可以直接在上面打断点调试，另外可以点击内容框的左下角大括号图标“{ }”(pretty print)，对代码进行排版美化。 参考文档： https://blog.csdn.net/m0_37724356/article/details/79884006]]></content>
      <categories>
        <category>实用技术</category>
        <category>Chrome</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome浏览器F12 Network中Timing参数含义]]></title>
    <url>%2F2019%2F03%2F17%2Fstudy%2Fchrome-timing%2F</url>
    <content type="text"><![CDATA[前言:Chrome浏览器开发者工具Network窗口下，Timing中显示资源在整个请求生命周期过程中各部分花费的时间 参数示例 参数详解Queueing请求文件顺序的排序。浏览器是有线程限制的，发请求也不能所有的请求同时发送，会将请求加入队列中（Chrome的最大并发连接数是6）。此参数表示从添加到待处理队列，到实际开始处理的时间间隔标示。 Stalled（阻塞）(1) 简介浏览器得到要发出这个请求的指令，到请求可以发出的等待时间，一般是代理协商、以及等待可复用的TCP连接释放的时间，不包括DNS查询、建立TCP连接等时间等。浏览器对同一个主机域名的并发连接数有限制，因此如果当前的连接数已经超过上限，那么其余请求就会被阻塞，等待新的可用连接；此外脚本也会阻塞其他组件的下载； (2) 优化措施 将资源合理分布到多台主机上，可以提高并发数，但是增加并行下载数量也会增大开销，这取决于带宽和CPU速度，过多的并行下载会降低性能； 脚本置于页面底部； DNS Lookup(1) 简介请求某域名下的资源，浏览器需要先通过DNS解析器得到该域名服务器的IP地址。在DNS查找完成之前，浏览器不能从主机名那里下载到任何东西。DNS查询的时间，当本地DNS缓存没有的时候，这个时间可能是有一段长度的，但是比如你一旦在host中设置了DNS，或者第二次访问，由于浏览器的DNS缓存还在，这个时间就为0了。 (2) 优化措施 利用DNS缓存（设置TTL时间）； 利用Connection:keep-alive特性建立持久连接，可以在当前连接上进行多个请求，无需再进行域名解析； Initial connection建立TCP连接的时间，就相当于客户端从发请求开始到TCP握手结束这一段，包括DNS查询+Proxy时间+TCP握手时间。 SSL（包含于HTTPS连接中）http是超文本传输协议，以明文方式发送内容，不提供任何方式的数据加密，如果被不法分子截取浏览器和服务器之间的传输报文，会获取其中的信息。https 是安全套接字层超文本传输协议，就是在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。因此建立HTTPS连接的时间相当于三次握手的时间+SSL时间。 Request sent（发送请求）(1) 简介发送HTTP请求的时间（从第一个字节发出前到最后一个字节发出后的时间） (2) 优化措施 减少HTTP请求，可以使用CSS Sprites、内联图片、合并脚本和样式表等； 对不常变化的组件添加长久的Expires头（相当于设置久远的过期时间），在后续的页面浏览中可以避免不必要的HTTP请求； Waiting(TTFB)(1) 简介请求发出后，到收到响应的第一个字节所花费的时间(Time To First Byte)，发送请求完毕到接收请求开始的时间；通常是耗费时间最长的。从发送请求到收到服务器响应的第一字节之间的时间，受到线路、服务器距离等因素的影响。 注意：网页重定向越多，TTFB越高，所以要减少重定向 (2) 优化措施使用CDN，将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求，提高响应速度； Content Download（下载）(1) 简介收到响应的第一个字节，到接受完最后一个字节的时间，就是下载时间。 (2) 优化措施 通过条件Get请求，对比If-Modified-Since和Last-Modified时间，确定是否使用缓存中的组件，服务器会返回“304 Not Modified”状态码，减小响应的大小； 移除重复脚本，精简和压缩代码，如借助自动化构建工具grunt、gulp等； 压缩响应内容，服务器端启用gzip压缩，可以减少下载时间； 参考文档：https://blog.csdn.net/lhz_333/article/details/93544313]]></content>
      <categories>
        <category>实用技术</category>
        <category>Chrome</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>Note</tag>
        <tag>Timing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2018%2F12%2F25%2FGit%2Fgit-command01%2F</url>
    <content type="text"><![CDATA[前言:本文记录的是常见的Git命令及其作用 仓库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 配置123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name "[name]"$ git config [--global] user.email "[email address]" 增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat "@&#123;0 day ago&#125;"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 其他12# 生成一个可供发布的压缩包$ git archive 参考链接1.常用Git命令清单2.在线Git命令学习平台3.最常见的-git-错误都有哪些，如何解决它们？]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git命令大全]]></title>
    <url>%2F2018%2F12%2F22%2FGit%2Fgit-command%2F</url>
    <content type="text"><![CDATA[前言:本文记录的是常见的Git命令及其作用 增删改查、找回，重置修改文件123456789101112131415git help # 显示command的helpgit show # 显示某次提交的内容 git show $idgit co – # 抛弃工作区修改git co . # 抛弃工作区修改git add # 将工作文件修改提交到本地暂存区git add . # 将所有修改过的工作文件提交暂存区git rm # 从版本库中删除文件git rm –cached # 从版本库中删除文件，但不删除git文件git reset # 从暂存区恢复到工作文件git reset – . # 从暂存区恢复到工作文件git reset –hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git ci git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做git ci -am “some comments”git ci –amend # 修改最后一次提交记录git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象git revert HEAD # 恢复最后一次提交的状态 查看文件diff123456git diff # 比较当前文件和暂存区文件差异 git diffgit diff # 比较两次提交之间的差异git diff .. # 在两个分支之间比较git diff –staged # 比较暂存区和版本库差异git diff –cached # 比较暂存区和版本库差异git diff –stat # 仅仅比较统计信息 查看提交记录123456git log git log # 查看该文件每次提交记录git log -p # 查看每次详细修改内容的diffgit log -p -2 # 查看最近两次详细修改内容的diffgit log –stat #查看提交统计信息tigMac上可以使用tig代替diff和log，brew install tig 查看、切换、创建和删除分支123456789101112git br -r # 查看远程分支git br &lt;new_branch&gt; # 创建新的分支git br -v # 查看各个分支最后提交信息git br –merged # 查看已经被合并到当前分支的分支git br –no-merged # 查看尚未被合并到当前分支的分支git co # 切换到某个分支git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去git co -b &lt;new_branch&gt; # 基于branch创建新的new_branchgit co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支git br -d # 删除某个分支git br -D # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebase123git merge # 将branch分支合并到当前分支git merge origin/master –no-ff # 不要Fast-Foward合并，这样可以生成merge提交git rebase master # 将master rebase到branch，相当于： git co &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge Git补丁管理(方便在多台机器上开发同步时用)123git diff &gt; ../sync.patch # 生成补丁git apply ../sync.patch # 打补丁git apply –check ../sync.patch #测试补丁能否成功 Git暂存管理1234git stash # 暂存git stash list # 列所有stashgit stash apply # 恢复暂存的内容git stash drop # 删除暂存区 Git补丁管理(方便在多台机器上开发同步时用)123git diff &gt; ../sync.patch # 生成补丁git apply ../sync.patch # 打补丁git apply –check ../sync.patch #测试补丁能否成功 Git远程分支管理123456789101112git pull # 抓取远程仓库所有分支更新并合并到本地git pull –no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并git fetch origin # 抓取远程仓库更新git merge origin/master # 将远程主分支合并到本地当前分支git co –track origin/branch # 跟踪某个远程分支创建相应的本地分支git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上git push # push所有分支git push origin master # 将本地主分支推到远程主分支git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d )，然后再push删除远程分支 Git远程仓库管理12345GitHubgit remote -v # 查看远程服务器地址和仓库名称git remote show origin # 查看远程服务器仓库状态git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm # 删除远程仓库 创建远程仓库123456789git clone –bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git –bare init # 在服务器创建纯仓库git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址git push -u origin master # 客户端首次提交git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且trackgit remote set-head origin master # 设置远程仓库的HEAD指向master分支,也可以命令设置跟踪远程库和本地库git branch –set-upstream master origin/mastergit branch –set-upstream develop origin/develop git init在本地新建一个repo,进入一个项目目录,执行git init,会初始化一个repo,并在当前文件夹下创建一个.git文件夹. git clone获取一个url对应的远程Git repo, 创建一个local copy.一般的格式是git clone [url].clone下来的repo会以url最后一个斜线后面的名称命名,创建一个文件夹,如果想要指定特定的名称,可以git clone [url] newname指定. git status查询repo的状态. 1git status -s: -s表示short, -s的输出标记会有两列,第一列是对staging区域而言,第二列是对working目录而言. git logshow commit history of a branch(查看历史提交信息). 123456789101112git log –oneline –number #每条log只显示一行,显示number条.git log –oneline –graph #可以图形化地表示出分支合并历史.git log branchname #可以显示特定分支的log.git log –oneline branch1 ^branch2 #可以查看在分支1,却不在分支2中的提交.^表示排除这个分支(Window下可能要给^branch2加上引号).git log –decorate #会显示出tag信息.git log –author=[author name] #可以指定作者的提交历史.git log –since –before –until –after #根据提交时间筛选log.–no-merges #可以将merge的commits排除在外.git log –grep #根据commit信息过滤log: git log –grep=keywords，默认情况下, git log –grep –author是OR的关系,即满足一条即被返回,如果你想让它们是AND的关系,可以加上–all-match的option.git log -S #filter by introduced diff，比如: git log -SmethodName (注意S和后面的词之间没有等号分隔).git log -p #show patch introduced at each commit.每一个提交都是一个快照(snapshot)Git会把每次提交的diff计算出来,作为一个patch显示给你看.另一种方法是git show [SHA].git log –stat #show diffstat of changes introduced at each commit.同样是用来看改动的相对信息的,–stat比-p的输出更简单一些. git add查询repo的状态. 12在提交之前,Git有一个暂存区(staging area),可以放入新添加的文件或者加入新的改动. commit时提交的改动是上一次加入到staging area中的改动,而不是我们disk上的改动.git add . #会递归地添加当前工作目录中的所有文件. git diff12345678910111213141516171819show diff of unstaged changes #此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容.若要看已经暂存起来的文件和上次提交时的快照之间的差异,可以用:git diff --cached 命令.show diff of staged changes.(Git 1.6.1 及更高版本还允许使用 git diff --staged，效果是相同的).git diff HEADshow diff of all staged or unstated changes.也即比较woking directory和上次提交之间所有的改动.如果想看自从某个版本之后都改动了什么,可以用:git diff [version tag]跟log命令一样,diff也可以加上--stat参数来简化输出.git diff [branchA] [branchB]可以用来比较两个分支.它实际上会返回一个由A到B的patch,不是我们想要的结果.一般我们想要的结果是两个分支分开以后各自的改动都是什么,是由命令:git diff [branchA]…[branchB]给出的.实际上它是:git diff $(git merge-base [branchA] [branchB]) [branchB]的结果. git commit1234提交已经被add进来的改动.git commit -m “the commit message”git commit -a 会先把所有已经track的文件的改动add进来,然后提交(有点像svn的一次提交,不用先暂存). 对于没有track的文件,还是需要git add一下.git commit –amend 增补提交. 会使用与当前提交节点相同的父节点进行一次新的提交,旧的提交将会被取消. git reset(1) 概述 1234567891011undo changes and commits.这里的HEAD关键字指的是当前分支最末梢最新的一个提交.也就是版本库中该分支上的最新版本.git reset HEAD: unstage files from index and reset pointer to HEAD这个命令用来把不小心add进去的文件从staged状态取出来,可以单独针对某一个文件操作: git reset HEAD - - filename, 这个- - 也可以不加.git reset –softmove HEAD to specific commit reference, index and staging are untouched.git reset –hardunstage files AND undo any changes in the working directory since last commit.使用git reset —hard HEAD进行reset,即上次提交之后,所有staged的改动和工作目录的改动都会消失,还原到上次提交的状态.这里的HEAD可以被写成任何一次提交的SHA-1.不带soft和hard参数的git reset,实际上带的是默认参数mixed. (2) 总结 12345git reset --mixed id,是将git的HEAD变了(也就是提交记录变了),但文件并没有改变，(也就是working tree并没有改变). 取消了commit和add的内容.git reset --soft id. 实际上，是git reset –mixed id 后,又做了一次git add.即取消了commit的内容.git reset --hard id.是将git的HEAD变了,文件也变了.按改动范围排序如下:soft (commit) &lt; mixed (commit + add) &lt; hard (commit + add + local working) git revert反转撤销提交.只要把出错的提交(commit)的名字(reference)作为参数传给命令就可以了. 12git revert HEAD: 撤销最近的一个提交.git revert会创建一个反向的新提交,可以通过参数-n来告诉Git先不要提交. git rm123git rm file: 从staging区移除文件,同时也移除出工作目录.git rm –cached: 从staging区移除文件,但留在工作目录中.git rm –cached从功能上等同于git reset HEAD,清除了缓存区,但不动工作目录树. git clean123git clean是从工作目录中移除没有track的文件.通常的参数是git clean -df:-d表示同时移除目录,-f表示force,因为在git的配置文件中, clean.requireForce=true,如果不加-f,clean将会拒绝执行. git mv1git rm - - cached orig; mv orig new; git add new git stash12345678910把当前的改动压入一个栈.git stash将会把当前目录和index中的所有改动(但不包括未track的文件)压入一个栈,然后留给你一个clean的工作状态,即处于上一次最新提交处.git stash list会显示这个栈的list.git stash apply:取出stash中的上一个项目(stash@&#123;0&#125;),并且应用于当前的工作目录.也可以指定别的项目,比如git stash apply stash@&#123;1&#125;.如果你在应用stash中项目的同时想要删除它,可以用git stash pop删除stash中的项目:git stash drop: 删除上一个,也可指定参数删除指定的一个项目.git stash clear: 删除所有项目. git branch12345678910git branch可以用来列出分支,创建分支和删除分支.git branch -v可以看见每一个分支的最后一次提交.git branch: 列出本地所有分支,当前分支会被星号标示出.git branch (branchname): 创建一个新的分支(当你用这种方式创建分支的时候,分支是基于你的上一次提交建立的).git branch -d (branchname): 删除一个分支.删除remote的分支:git push (remote-name) :(branch-name): delete a remote branch.这个是因为完整的命令形式是:git push remote-name local-branch:remote-branch而这里local-branch的部分为空,就意味着删除了remote-branch git checkout1234567git checkout (branchname) #切换到一个分支.git checkout -b (branchname) #创建并切换到新的分支.这个命令是将git branch newbranch和git checkout newbranch合在一起的结果.checkout还有另一个作用:替换本地改动:git checkout –此命令会使用HEAD中的最新内容替换掉你的工作目录中的文件.已添加到暂存区的改动以及新文件都不会受到影响.注意:git checkout filename会删除该文件中所有没有暂存和提交的改动,这个操作是不可逆的. git merge把一个分支merge进当前的分支. 123git merge [alias]/[branch] #把远程分支merge到当前分支.如果出现冲突,需要手动修改,可以用git mergetool.解决冲突的时候可以用到git diff,解决完之后用git add添加,即表示冲突已经被resolved. git tag12345tag a point in history as import.会在一个提交上建立永久性的书签,通常是发布一个release版本或者ship了什么东西之后加tag.比如: git tag v1.0git tag -a v1.0, -a参数会允许你添加一些信息,即make an annotated tag.当你运行git tag -a命令的时候,Git会打开一个编辑器让你输入tag信息. git remote1234567git remote #列出remote aliases.如果你clone一个project,Git会自动将原来的url添加进来,别名就叫做:origin.git remote -v #可以看见每一个别名对应的实际url.git remote add [alias] [url] #添加一个新的remote repo.git remote rm [alias] #删除一个存在的remote alias.git remote rename [old-alias] [new-alias] #重命名.git remote set-url [alias] [url] #更新url. 可以加上—push和fetch参数,为同一个别名set不同的存取地址. git fetch123download new branches and data from a remote repository.可以git fetch [alias]取某一个远程repo,也可以git fetch –all取到全部repofetch将会取到所有你本地没有的数据,所有取下来的分支可以被叫做remote branches,它们和本地分支一样(可以看diff,log等,也可以merge到其他分支),但是Git不允许你checkout到它们. git pull1234fetch from a remote repo and try to merge into the current branch.pull == fetch + merge FETCH_HEADgit pull会首先执行git fetch,然后执行git merge,把取来的分支的head merge到当前分支.这个merge操作会产生一个新的commit.如果使用–rebase参数,它会执行git rebase来取代原来的git merge. git rebase1234–rebase不会产生合并的提交,它会将本地的所有提交临时保存为补丁(patch),放在”.git/rebase”目录中,然后将当前分支更新到最新的分支尖端,最后把保存的补丁应用到分支上.rebase的过程中,也许会出现冲突,Git会停止rebase并让你解决冲突,在解决完冲突之后,用git add去更新这些内容,然后无需执行commit,只需要:git rebase –continue就会继续打余下的补丁.git rebase –abort将会终止rebase,当前分支将会回到rebase之前的状态. git push123git push [alias] [branch]将会把当前分支merge到alias上的[branch]分支.如果分支已经存在,将会更新,如果不存在,将会添加这个分支.如果有多个人向同一个remote repo push代码, Git会首先在你试图push的分支上运行git log,检查它的历史中是否能看到server上的branch现在的tip,如果本地历史中不能看到server的tip,说明本地的代码不是最新的,Git会拒绝你的push,让你先fetch,merge,之后再push,这样就保证了所有人的改动都会被考虑进来. git reflog1234git reflog是对reflog进行管理的命令,reflog是git用来记录引用变化的一种机制,比如记录分支的变化或者是HEAD引用的变化.当git reflog不指定引用的时候,默认列出HEAD的reflog.HEAD@&#123;0&#125;代表HEAD当前的值,HEAD@&#123;3&#125;代表HEAD在3次变化之前的值.git会将变化记录到HEAD对应的reflog文件中,其路径为.git/logs/HEAD, 分支的reflog文件都放在.git/logs/refs目录下的子目录中. 特殊符号12^代表父提交,当一个提交有多个父提交时,可以通过在^后面跟上一个数字,表示第几个父提交: ^相当于^1.~相当于连续的个^.]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[批量修改文件名称与格式]]></title>
    <url>%2F2018%2F12%2F06%2Fpython%2Frename-file%2F</url>
    <content type="text"><![CDATA[前言:主要介绍一下如何利用Python脚本实现给指定的文件数据集按照一定的格式批量重命名，文件不单指图片，其他格式的也可以，此处以图片转换为例，希望能够帮到您(^_−)☆ Python脚本(1) 写的是python脚本，需要安装python环境，安装教程可自行百度(2) 桌面新建test1.txt文档后将其改为test1.py,打开文档，将以下内容粘贴进去 12345678910111213141516171819202122232425262728293031# -*- coding:utf8 -*- import osclass BatchRename(): ''' 批量重命名文件夹中的图片文件 ''' def __init__(self): self.path = 'E:\Pictures\' #存放图片的文件夹路径，注意转义字符(\b、\t等) def rename(self): filelist = os.listdir(self.path) total_num = len(filelist) i = 1 for item in filelist: if item.endswith('.jpg'): #指定选取的图片格式为jpg src = os.path.join(os.path.abspath(self.path), item) # 2018-11-20_bqb00 2018-11-20_hzw00 dst = os.path.join(os.path.abspath(self.path), '2018-11-20_00' + str(i) + '.png') #设置新的图片名称 try: os.rename(src, dst) print ("转换图片 %s 成为 %s ..." % (src, dst)) i = i + 1 except: continue print ("共 %d 张图片重命名和转换成 %d jpgs" % (total_num, i-1))if __name__ == '__main__': demo = BatchRename() demo.rename() (3) 只要按自己的需求修改脚本中的中文注释部分即可，上述脚本的功能是：将E:\Pictures\目录下的jpg格式的图片批量重命名为2018-11-20_00形式的png图片 注意路径中的转义字符，例如F:\picture\blog要写成F:\picture\\blog(4) 在桌面按住shift+鼠标右键，打开打开PowerShell窗口，执行python test1.py命令,出现如下结果： 懒人专用 上面的脚本还有手动输入命令执行，我不想输命令怎么办呢？(1) 在test1.py同级目录(此处为桌面)新建一个test2.txt文档，打开文档，将以下内容粘贴进去： 12# 执行批量修改图片脚本python test1.py (2) 保存之后将test2.txt改为test2.bat，然后双击就能自动执行上述python脚本文件 注：test2.bat一定要和test2.py在同一目录 参考链接：https://blog.csdn.net/u014797226/article/details/80028459]]></content>
      <categories>
        <category>Python</category>
        <category>tools</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM性能分析常用的命令]]></title>
    <url>%2F2018%2F12%2F04%2Fjava%2FJVM%2Fjvm01%2F</url>
    <content type="text"><![CDATA[前言:JVM性能分析常用的命令，包括jstack(查看jvm线程运行状态)、jps(显示本地的java进程及对应进程号)、jstat(监视VM内存工具)、jinfo(输出并修改运行时的java进程的opts)、jmap(查看堆内存使用状况)、jconsole(java GUI监视工具)、jvisualvm(JVM运行监控工具)注意：在使用这些工具前，先用JPS命令获取当前的每个JVM进程号[pid]，然后选择要查看的JVM jstack功能查看jvm线程运行状态，是否有死锁现象等等信息. 常用命令123jstack pid :thread dump //查看对应进程的jstack的相关语法jstack –l pid //查看对应的线程信息jstack –l pid &gt;E:\luxiong.txt //上述结果打印到指定文档 jps功能与unix上的ps类似，用来显示本地的java进程，可以查看本地运行着几个java程序，并显示他们的进程号. 常用命令1用法命令行(cmd)里打 jps就行了 jstat功能jstat工具特别强大，有众多的可选项，详细查看堆内各个部分的使用量，以及加载类的数量。使用时，需加上查看进程的进程id，和所选参数. 常用命令1234567891011121314151617//单个参数jstat -class pid //显示加载class的数量，及所占空间等信息.jstat -compiler pid //显示VM实时编译的数量等信息.jstat -gc pid //可以显示gc的信息，查看gc的次数，及时间。其中最后五项，分别是young gc的次数，young gc的时间，full gc的次数，full gc的时间，gc的总时间.jstat -gccapacity pid //可以显示，VM内存中三代（young,old,perm）对象的使用和占用大小，如：PGCMN显示的是最小perm的内存使用量，PGCMX显示的是perm的内存最大使用量，PGC是当前新生成的perm内存占用量，PC是但前perm内存占用量。其他的可以根据这个类推， OC是old内纯的占用量.jstat -gcnew pid //new对象的信息.jstat -gcnewcapacity pid //new对象的信息及其占用量.jstat -gcold pid //old对象的信息.jstat -gcoldcapacity pid //old对象的信息及其占用量.jstat -gcpermcapacity pid //perm对象的信息及其占用量.jstat -util pid //统计gc信息统计.jstat -printcompilation pid //当前VM执行的信息.//多个参数jstat -class pid 250 6 //每250毫秒打印一次，一共打印6次.jstat -class -h2 pid 250 6 //上述基础上增加每2行显示一下标题.jstack -gcutil pid 1000 100 //每1000ms统计一次gc情况统计100次jstat -gcutil pid 2000 &gt;E:luxiong.txt //将上述结果生成指定文件. jinfo功能可以输出并修改运行时的java进程的运行参数(opts). 常用命令12jinfo -opt pid //用法示例(opt表示对应参数,如下示例)jinfo -flag MaxPermSize pid //查看进程pid的MaxPerm大小 jmap功能jmap是一个可以输出所有内存中对象的工具，甚至可以将VM 中的heap，以二进制输出成文本. 常用命令1234jmap -dump:format=b,file=E:\luxiong.bin pid //file-保存路径及文件名 pid-进程编号 jmap -dump:file=E:\luxiong.dump pid //file-保存路径及文件名 pid-进程编号 jmap -histo:live pid //堆中活动的对象以及大小jmap -heap pid //查看堆的使用状况信息 jconsole功能用java写的GUI程序，用来监控VM，并可监控远程的VM，非常易用，而且功能非常强. 常用命令1用法命令行(cmd)里打 jconsole，选则相应的进程就行了 jvisualvm功能用来监控JVM的运行情况，可以用它来查看和浏览Heap、Dump、ThreadDump、内存对象实例情况、GC执行情况、CPU消耗以及类的装载情况。该工具位于JDK根目录的bin文件夹下面，无需安装，正常装完jdk吼直接在bin目录下运行jvisual.exe即可. 常用命令1用法命令行(cmd)里打 jvisualvm，选则相应的进程就可以(功能远比jconsole强大) 解析（1）概述：显示当前服务器(resin)的整体运行状况 （2）监视：可实时动态显示cpu、堆栈、类、线程的相关信息(类似于jconsole的升级版) （3）线程：可实时动态的现实进程的使用状况点击[==线程Dump==]按钮 可以显示具体的进程的内容，可从此页面查看到进程的具体信息以及报错信息(类似于jstack命令的查看结果) （4）：显示当前服务器(resin)的整体运行状况 参考文档1.https://blog.csdn.net/u012550080/article/details/816051892.http://www.51testing.com/html/38/n-3724238.html3.https://blog.51cto.com/zero01/2141942]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程的七种状态]]></title>
    <url>%2F2018%2F11%2F04%2Fjava%2Fjava-thread%2F</url>
    <content type="text"><![CDATA[前言:本文简单介绍一下Java线程的七种状态 Java线程有7种状态，分别是:1. 新建状态(new)（1）使用new操作符新创建的一个线程对象，例如new Thread();（2）处于新建状态的线程，内部的任务代码还没开始运行. 2. 可执行/就绪状态(Runnable)（1）新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当调用了线程对象的start()方法即启动了线程，此时线程就处于就绪状态;（2）处于就绪状态的线程并不一定立即运行run()方法，线程还必须==同其他就绪线程竞争CPU==，只有==获得CPU使用权才可以运行线程==;（3）线程阻塞状态(Blocked)结束后也可以变成就绪状态，或从运行状态(Running)变化到就绪状态. 3. 运行状态(Running)（1）线程获取到CPU使用权进行执行;（2）需要注意的是，==线程只能从就绪状态进入到运行状态==,真正开始执行run()方法的内容. 4. 阻塞状态(Blocked)（1）线程在获取锁失败时(因为锁被其它线程抢占)，它会被加入锁的同步阻塞队列，然后线程进入阻塞状态(Blocked);（2）待其它线程释放锁之后，阻塞状态(Blocked)的线程将在次参与锁的竞争，如果==竞争锁成功==，==线程将进入就绪状态==(Runnable),之后才有机会转到运行状态(Running). 5. 等待状态(Waiting)（1）线程执行wait()方法，JVM会把该线程放入等待队列(waitting queue)中,进入等待状态;（2）处于等待状态的线程将不会被CPU执行，除非线程的运行条件得到满足后，其==可被其他线程唤醒==，进入阻塞状态(Blocked);（3）调用不带超时的Thread.join()方法也会进入等待状态. 6. 睡眠(Sleep)（1）睡眠是等待状态的一种特例，在调用Thread.sleep()方法，带有超时设定的Object.wait()方法，带有超时设定的Thread.join()方法等，线程会进入睡眠状态(Sleep);（2）睡眠状态进程达到设置时间的等待时间后，睡眠线程将==自动唤醒进入阻塞状态==(Blocked)或就绪状态(Runnable). 7. 死亡(Dead)（1）线程执行完了或者因异常退出了run()方法，该线程结束生命周期,死亡的线程==不可再次复生==. 参考文档1.https://baijiahao.baidu.com/s?id=1626410873162104506&amp;wfr=spider&amp;for=pc]]></content>
      <categories>
        <category>Java</category>
        <category>Thread</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法]]></title>
    <url>%2F2018%2F09%2F23%2Fstudy%2Fmarkdown01%2F</url>
    <content type="text"><![CDATA[简单介绍一下Markdown的基本语法(未完善，待补充…) 标题在想要设置为标题的文字前面加#来表示注：标准语法一般在#后跟个空格再写文字（1）示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 （2）效果：由于标题演示效果会影响目录结构，故不展示效果 字体（1）简介 加粗要加粗的文字左右分别用两个*号包起来 斜体要加粗的文字左右分别用一个*号包起来 斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来 删除线要加删除线的文字左右分别用两个~~号包起来 （2）示例： 1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ （3）效果：这是加粗的文字这是倾斜的文字这是斜体加粗的文字这是加删除线的文字 引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;等等 （1）示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 （2）效果： 这是引用的内容 这是引用的内容 这是引用的内容 分割线三个或者三个以上的 - 或者 * 都可以 （1）示例： 1234-------******** （2）效果： 图片（1）简介基本语法：![图片alt](图片URL&quot;图片title&quot;&quot;)图片alt:显示在图片下面的文字，相当于对图片内容的解释;图片URL:图片的链接URL图片title:当鼠标移到图片上时显示的内,title可加可不加(==URL和title之间有个空格==) （2）示例： 1![这是一张示例图片](https://ibb.co/album/kshZBF ''海贼王'') （3）效果： 图片必须配合链接使用，所以必须有一个好的图床工具： 七牛云：https://www.qiniu.com/ ImgBB：https://imgbb.com/ 聚合图床：https://www.superbed.cn/百度直接搜索关键字“免费图床”，可以搜到一堆 超链接初级链接（1）基本语法：[超链接名](超链接URL &quot;超链接title&quot;)title可加可不加,语法参照图片 （2）示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) （3）效果：简书百度 高级链接（1）示例 1234567链接也可以用变量来代替，文档末尾附带变量地址：这个链接用 1 作为网址变量 [Google][1]这个链接用 runoob 作为网址变量 [Runoob][runoob]然后在文档的结尾为变量赋值（网址） [1]: http://www.google.com/ [runoob]: http://www.runoob.com/ （2）效果百度简书 注：Markdown本身语法不支持链接在新页面中打开，如果想要在新页面中打开的话可以用html语言的a标签代替。例如： 12示例&lt;a href="https://www.jianshu.com/u/1f5ac0cf6a8b" target="_blank"&gt;简书&lt;/a&gt; 列表列表分为无序列表和有序列表 无序列表无序列表用 - + * 任何一种都可以 （1）示例： 12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 （2）效果： 列表内容 列表内容 列表内容 有序列表数字加点 （1）示例： 123451. 列表内容2. 列表内容3. 列表内容注意：序号跟内容之间要有空格 （2）效果： 列表内容 列表内容 列表内容 注意：序号跟内容之间要有空格 列表嵌套 一级无序列表 二级无序列表 二级无序列表 一级无序列表 二级有序列表 二级有序列表 表格（1）语法： 1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 （2）示例： 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 （3）效果：姓名|技能|排行–|:–:|–:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 代码单行代码代码之间分别用一个反引号包起来（1）示例： 1`create database hero;` （2）效果：create database hero; 多行代码代码之间分别用三个反引号包起来，且两边的反引号单独占一行示例及效果： 1234function fun()&#123; echo "这是一句非常牛逼的代码";&#125;fun(); 流程图公式流程图时序图甘特图 待办事项- [x]：表示已完成- [ ]：表示未完成（1）示例： 123456- [x] 已完成项目1 - [x] 已完成事项1 - [x] 已完成事项2- [ ] 待完成项目1 - [ ] 待完成事项1 - [ ] 待完成事项2 （2）效果： 已完成项目1 已完成事项1 已完成事项2 待完成项目1 待完成事项1 待完成事项2 高级技巧支持的 HTML 元素（1）简介目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等（2）示例 123456&lt;b&gt;test&lt;/b&gt; &lt;i&gt;test&lt;/i&gt; &lt;em&gt;test&lt;/em&gt; &lt;sup&gt;test&lt;/sup&gt; &lt;sub&gt;test&lt;/sub&gt; &lt;br&gt;test&lt;/br&gt; （3）效果testtesttesttesttesttest 转义（1）简介Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符（2）示例 12**文本加粗** \*\* 正常显示星号 \*\* （3）效果文本加粗** 正常显示星号 ** 参考文档：1.有道云笔记Markdown指南2.菜鸟教程]]></content>
      <categories>
        <category>实用技术</category>
        <category>Markdown教程</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客插件、展望]]></title>
    <url>%2F2018%2F09%2F04%2Fhexo%2Fhexo-blog04%2F</url>
    <content type="text"><![CDATA[前言:介绍博客的一些用法、功能以及相关插件… 相关插件Hexo相关初始化配置1npm install -g hexo-cli 安装自动部署发布工具1npm install hexo-deployer-git --save 分页插件1234npm install --save hexo-generator-indexnpm install --save hexo-generator-archivenpm install --save hexo-generator-tagnpm install --save hexo-generator-category 文章字数与阅读时长 wordcount 插件1npm install hexo-wordcount --save RSS订阅功能1npm install hexo-generator-feed --save 站内搜索1npm install --save hexo-generator-searchdb Gitment评论1npm i --save gitment 文章加密1npm install --save hexo-blog-encrypt hexo-admin文章管理1npm install --save hexo-admin 图片上传相册 git连接远程Blog_Album 此小块所有命令均在Blog_Album目录下打开终端执行(1) 执行git remote add origin https://github.com/luxiong-github/Blog_Album.git为本地仓库添加一个远程仓库如果此处出现fatal: remote origin already exists.错误，说明远程起源已经存在，则先执行git remote rm origin再执行上述命令(2) 拉取远程仓库代码：git pull --rebase origin master(远程仓库被更新本地没更新才需要执行)git pull --rebase origin master 上传照片(1) 将照片放到Blog_Album\photos目录中，命名格式：yyyy-MM-dd_des.jpg/jpeg/gif/png.(脚本解析jpg有问题，最好使用png)(2) 终端切换到Blog_Album目录下(或者直接在Blog_Album目录下shift+鼠标右键打开PowerShell窗口),执行python tool.py命令 如果出现error: failed to push some refs to错误，说明本地没有update到最新版本的项目（git上有README.md文件没下载下来）,执行此处命令(3) 如果上述命令执行无误，则可进入自己GitHub的Blog_Album仓库中进行查看(4) hexo g &amp;&amp; hexo s进入博客查看 参考：https://malizhi.cn/HexoAlbum/ 源码提交gitee(1) my-blog目录下打开终端，输入命令初始化创建一个空的本地仓库： 1git init (2) 将本地库与远程仓库(gitee)进行链接： 1git remote add origin https://gitee.com/luxiong-gitee/blog-code.git (3) 将项目的所有文件添加到缓存中： 1git add . (4) 将缓存中的文件Commit到git库： 1git commit -m "项目源码上传" (5) 上传代码之前最好先pull一下(拉取远程仓库最新代码)： 1git pull origin master (6) 代码提交到远程库： 1git push origin master 待优化项目 Fork me on GitHub 123&lt;a href="https://github.com/luxiong-github"&gt; &lt;img width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_darkblue_121621.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"&gt;&lt;/a&gt; 流程图 相册 https://malizhi.cn/HexoAlbum/ https://www.jianshu.com/p/7f6425b3ffb2 URL优化 站点提交百度、Google https://malizhi.cn/nextTutorial/#more]]></content>
      <categories>
        <category>Hexo个人博客搭建</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Blog</tag>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客搭建-加强]]></title>
    <url>%2F2018%2F09%2F02%2Fhexo%2Fhexo-blog03%2F</url>
    <content type="text"><![CDATA[前言:给博客增加一些更高级的功能，例如分页、站内搜索、评论… Hexo文章加密简介(1) 尝试着想一下，你写了一篇博客，但是，出于某种原因，不太希望每一个人都可以看到他。所以你常常会为这种文章设置一个密码，其他人需要输入密码才可以访问这篇博客。所以Hexo-Blog-Encrypt 因为这个需求而诞生了(2) 一旦你输入了正确的密码，你可以在接下来的 30 分钟内，无需密码访问该网页 安装(1) 命令： 123npm install --save hexo-blog-encrypt # npm安装yarn add hexo-blog-encrypt # yarn安装 (2) 在站点配置文件_config.yml中添加插件配置： 123456# Securityencrypt: # hexo-blog-encrypt enable: true tags: # 配置标签加密 - &#123;name: test, password: test&#125; - &#123;name: diary, password: diary&#125; (3) 文章头部添加对应字段，如password, abstract, message： 1234567---title: Hello Worlddate: 2016-03-30 21:18:02password: mikemessi # 该博客加密使用的密码abstract: Something was encrypted, please enter password to read. #该博客的摘要，会显示在博客的列表页message: Welcome to my blog, please enter password to read. #博客查看时，密码输入框上面的描述性文字--- (4) hexo clean &amp;&amp; hexo g &amp;&amp; hexo s，来查看效果 注意事项(1) 文章设置的password优先级最高，其次是设置标签加密，文章多标签加密密码优先级跟文章标签先后顺序有关(2) 密码的有效时间是30分钟(3) 插件还可以对TOC进行加密以及修改加密模板，详情见参考链接(4) 加密后的文章可能会有不显示文章目录的bug，解决方案：将next/layout/_macro/sidebar.swig替换为这个博客中的文件 参考链接：https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md Valine评论安装使用Next主题，本身就已经集成了valine，因此正常情况下只需要配置一下就行了，不用安装，需要安装的可以使用以下命令： 1234# Install leancloud's js-sdknpm install leancloud-storage --save# Install valinenpm install valine --save Leancloud配置(1) 之前的文章次数统计已经配置过了，这里只需要进入Leancloud获取对应的APP ID和APP KEY就行了(2) 修改主题配置文件hexo\themes\next\_config.yml，修改以下参数： 12345678910valine: enable: true //打开valine评论功能 appid: 你的leancloud appid appkey: 你的leancloud appkey notify: false //邮件提醒 verify: true //评论时是否有验证码，需要在Leancloud 设置-&gt;安全中心 中打开 placeholder: 说点什么吧！ //评论框默认显示 avatar: monsterid //评论者的头像 guest_info: nick # custom comment header pageSize: 10 # pagination size (3) 评论者头像avatar取值与显示效果如下： hexo管理插件hexo-admin(1) 安装插件 1npm install --save hexo-admin (2) 测试hexo s启动服务，访问http://localhost:4000/admin/，就可以看到管理页面 功能说明 Pages：新加 page Posts：新加或删除 post；双击一个 post，你可以编辑，预览，新增修改 tags、categories，选择发布或不发布 Settings：一些配置 Deploy：可以直接部署到 github(1) 密码保护打开Setting，点击Setup authentification here输入用户名，密码，密钥，下面会自动生成配置文件，复制加在hexo根目录下的_config.yml中：1234admin: username: myfavoritename password_hash: be121740bf988b2225a313fa1f107ca1 secret: a secret something (2) 发布文章进入后台之后点击Deploy，里面的Deploy按钮是用来执行发布脚本的，所以我们先在博客根目录下新建个目录脚本文件hexo-deploy.bat(window系统，Linux系统可参考链接)，里面写下下面代码然后保存: 1hexo g -d 然后在hexo根目录下的_config.yml中的admin下添加： 12345admin: username: myfavoritename password_hash: be121740bf988b2225a313fa1f107ca1 secret: a secret something deployCommand: './hexo-deploy.bat' #新增参数 点击Deploy就会执行这个命令并提交到GitHub上 参考：(1) https://github.com/jaredly/hexo-admin(2) https://blog.csdn.net/dataiyangu/article/details/83066586(3) https://albenw.github.io/posts/4ffa5bc6/(4) https://segmentfault.com/a/1190000018488921 相册 注：Next主题默认是不含有相册页面的,如果想添加此页面需自行编写 相册和视频导航栏其他配置博客相册页面图片的处理 小功能集合文章链接唯一化hexo默认提供的文章链接方案是使用年/月/日/标题，也许你会数次更改文章题目或者变更文章发布时间，文章链接都会改变，不利于搜索引擎收录，也不利于分享。唯一永久链接才是更好的选择(1) 安装插件 1npm install hexo-abbrlink --save (2) 在站点配置文件中查找代码permalink，将其更改为: 1permalink: posts/:abbrlink/ # “posts/” 可自行更换 参考(1) https://malizhi.cn/HexoAlbum/(2) https://www.jianshu.com/p/7f6425b3ffb2]]></content>
      <categories>
        <category>Hexo个人博客搭建</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Blog</tag>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客搭建-完善]]></title>
    <url>%2F2018%2F08%2F31%2Fhexo%2Fhexo_blog02%2F</url>
    <content type="text"><![CDATA[前言:给博客增加一些更高级的功能，例如分页、站内搜索、评论… 细节完善分页(1) 插件安装(按需安装) 123npm install --save hexo-generator-index # 首页分页配置# npm install --save hexo-generator-archive # 归档分页配置# npm install --save hexo-generator-tag # 标签分页配置 (2) 站点配置文件： 1234567891011index_generator: path: '' per_page: 5 order_by: -date#archive_generator:# per_page: 20# yearly: true# monthly: true#tag_generator:# per_page: 10 (3) 清缓存hexo clean，重新生成hexo g，启动服务hexo s，查看效果 文章相关 详情请参考：https://tianbozhang.coding.me/personal-blog-custom.html 分页(1) 插件安装(按需安装) 123npm install --save hexo-generator-index # 首页分页配置# npm install --save hexo-generator-archive # 归档分页配置# npm install --save hexo-generator-tag # 标签分页配置 (2) 站点配置文件： 1234567891011index_generator: path: '' per_page: 5 order_by: -date#archive_generator:# per_page: 20# yearly: true# monthly: true#tag_generator:# per_page: 10 (3) 清缓存hexo clean，重新生成hexo g，启动服务hexo s，查看效果 博文置顶(1) 修改hexo-generator-index插件将node_modules/hexo-generator-index/lib/generator.js文件替换为：generator.js(2)在文章Front-matter中添加top值，数值越大文章越靠前，如： 12345678---title: Naruto 图集categories: [图片]tags: [picture,naruto]date: 2016-09-02 14:36:04keywords: picture,narutotop: 10--- 头像圆形旋转介绍一下实现头像圆形，鼠标经过旋转或者一直让旋转效果，主要是修改hexo目录下\themes\next\source\css\_common\components\sidebar\sidebar-author.styl文件(1) 头像圆形修改修改sidebar-author.styl文件中.site-author-imageCSS 样式如下： 12345678910111213.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /*头像圆形*/ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px;&#125; (2) 鼠标经过旋转修改修改sidebar-author.styl文件，添加 CSS 样式img:hover如下代码： 123456img:hover &#123; /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125; 修改sidebar-author.styl文件中.site-author-imageCSS 样式如下： 12345678910111213141516171819.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125; (3) 鼠标经过旋转修改修改sidebar-author.styl文件，添加如下代码： 12345678910111213141516171819202122232425/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(360deg); &#125;&#125; 修改sidebar-author.styl文件中.site-author-imageCSS 样式如下： 12345678910111213141516171819202122232425.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画：animation:动画名称 动画播放时长单位秒或微秒 动画播放的速度曲线linear为匀速 动画播放次数infinite为循环播放; */ -webkit-animation: play 3s linear infinite; -moz-animation: play 3s linear infinite; animation: play 3s linear infinite; /* 鼠标经过头像旋转360度 -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;*/&#125; 鼠标经过停止头像旋转：修改sidebar-author.styl文件，添加 CSS 样式img:hover如下代码： 12345678910img:hover &#123; /* 鼠标经过停止头像旋转 */ -webkit-animation-play-state:paused; animation-play-state:paused; /* 鼠标经过头像旋转360度 -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);*/&#125; 页面点击小红心(1) 在/themes/next/source/js/src下新建文件clicklove.js，接着把该链接下的代码拷贝粘贴到clicklove.js文件中。代码如下： 12// 页面点击爱心效果!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); (2) 在\themes\next\layout\_layout.swig文件末尾添加： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/clicklove.js"&gt;&lt;/script&gt; (3) 清缓存hexo clean，重新生成hexo g，启动服务hexo s检验效果 动态title崩溃欺骗(1) \themes\next\source\js\src，新建custom-title.js 12345678910111213141516&lt;!--崩溃欺骗--&gt;var OriginTitile = document.title;var titleTime;document.addEventListener('visibilitychange', function () &#123; if (document.hidden) &#123; $('[rel="icon"]').attr('href', "/img/TEP.ico"); document.title = ' 页面崩溃啦 ~ ！'; clearTimeout(titleTime); &#125; else &#123; $('[rel="icon"]').attr('href', "/favicon.ico"); document.title = ' 噫又好了~ ' + OriginTitile; titleTime = setTimeout(function () &#123; document.title = OriginTitile;&#125;, 2000); &#125;&#125;); (2) 更改\themes\next\layout_layout.swig,在文件末尾添加： 12&lt;!--动态title崩溃欺骗,卖萌专用--&gt;&lt;script type="text/javascript" src="/js/src/custom-title.js"&gt;&lt;/script&gt; (3) 清缓存hexo clean，重新生成hexo g，启动服务hexo s检验效果 High一下(1) header位置更改themes\next\layout_custom\header.swig,在文件末尾添加：sidebar位置更改themes\next\layout_custom\sidebar.swig(2) 添加以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;li&gt; &lt;a title="把这个链接拖到你的Chrome收藏夹工具栏中" href='javascript:(function() &#123; function c() &#123; var e = document.createElement("link"); e.setAttribute("type", "text/css"); e.setAttribute("rel", "stylesheet"); e.setAttribute("href", f); e.setAttribute("class", l); document.body.appendChild(e) &#125; function h() &#123; var e = document.getElementsByClassName(l); for (var t = 0; t &lt; e.length; t++) &#123; document.body.removeChild(e[t]) &#125; &#125; function p() &#123; var e = document.createElement("div"); e.setAttribute("class", a); document.body.appendChild(e); setTimeout(function() &#123; document.body.removeChild(e) &#125;, 100) &#125; function d(e) &#123; return &#123; height : e.offsetHeight, width : e.offsetWidth &#125; &#125; function v(i) &#123; var s = d(i); return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r &#125; function m(e) &#123; var t = e; var n = 0; while (!!t) &#123; n += t.offsetTop; t = t.offsetParent &#125; return n &#125; function g() &#123; var e = document.documentElement; if (!!window.innerWidth) &#123; return window.innerHeight &#125; else if (e &amp;&amp; !isNaN(e.clientHeight)) &#123; return e.clientHeight &#125; return 0 &#125; function y() &#123; if (window.pageYOffset) &#123; return window.pageYOffset &#125; return Math.max(document.documentElement.scrollTop, document.body.scrollTop) &#125; function E(e) &#123; var t = m(e); return t &gt;= w &amp;&amp; t &lt;= b + w &#125; function S() &#123; var e = document.createElement("audio"); e.setAttribute("class", l); e.src = i; e.loop = false; e.addEventListener("canplay", function() &#123; setTimeout(function() &#123; x(k) &#125;, 500); setTimeout(function() &#123; N(); p(); for (var e = 0; e &lt; O.length; e++) &#123; T(O[e]) &#125; &#125;, 15500) &#125;, true); e.addEventListener("ended", function() &#123; N(); h() &#125;, true); e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;"; document.body.appendChild(e); e.play() &#125; function x(e) &#123; e.className += " " + s + " " + o &#125; function T(e) &#123; e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)] &#125; function N() &#123; var e = document.getElementsByClassName(s); var t = new RegExp("\\b" + s + "\\b"); for (var n = 0; n &lt; e.length; ) &#123; e[n].className = e[n].className.replace(t, "") &#125; &#125; var e = 30; var t = 30; var n = 350; var r = 350; var i = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3"; var s = "mw-harlem_shake_me"; var o = "im_first"; var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"]; var a = "mw-strobe_light"; var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css"; var l = "mw_added_css"; var b = g(); var w = y(); var C = document.getElementsByTagName("*"); var k = null; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; if (E(A)) &#123; k = A; break &#125; &#125; &#125; if (A === null) &#123; console.warn("Could not find a node of the right size. Please try a different page."); return &#125; c(); S(); var O = []; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; O.push(A) &#125; &#125;&#125;)() '&gt;High一下&lt;/a&gt; &lt;/li&gt; (3) 代码块的内容不需要再做任何修改,清缓存hexo clean，重新生成hexo g，启动服务hexo s查看效果 底部增加运行时间(1) 修改themes/next/layout/_partials/footer.swig，增加如下代码： 123456789101112131415161718&lt;!-- 在网页底部添加网站运行时间 --&gt;&lt;span id="timeDate"&gt;载入天数...&lt;/span&gt;&lt;span id="times"&gt;载入时分秒...&lt;/span&gt;&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date("07/21/2018 00:00:00");//此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = "0" + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = "0" + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = "0" + snum;&#125; document.getElementById("timeDate").innerHTML = "Run for "+dnum+" Days "; document.getElementById("times").innerHTML = hnum + " Hours " + mnum + " m " + snum + " s"; &#125;setInterval("createtime()",250);&lt;/script&gt; (2) 运行效果： 当前所在菜单下划线显示(1) 打开themes\next\layout\ _partials目录下的header.swig文件(2) 在底部添加以下代码： 123456789101112131415&lt;script&gt; window.onload = function()&#123; var path = 'https://malizhi.cn'; //这里要改成你博客的地址 var localhostItem = String(window.location).split(path)[1]; var LiNode = document.querySelectorAll('#menu &gt; li &gt; a') for(var i = 0; i&lt; LiNode.length;i++)&#123; var item = String(LiNode[i].href).split(path)[1]; if(item == localhostItem &amp;&amp; item != undefined)&#123; LiNode[i].setAttribute('style','border-bottom:1px solid black'); &#125; &#125; &#125;;&lt;/script&gt; (3) hexo clean &amp;&amp; hexo g &amp;&amp; hexo s后完成效果： 底部跳动图标实现(1) 在next\layout_partials下的footer.swig文件中，在你所需要调动的图标所对应的span中增加对应的ID(2) 在主题的css文件next\source\css\_variables\custom.styl ，增加以下代码即可： 123456789101112131415//底部爱心小图标跳动keyframes heartAnimate &#123; 0%,100%&#123;transform:scale(1);&#125; 10%,30%&#123;transform:scale(0.9);&#125; 20%,40%,60%,80%&#123;transform:scale(1.1);&#125; 50%,70%&#123;transform:scale(1.1);&#125;&#125;//图标所对应的span中的ID#heart &#123; animation: heartAnimate 1.33s ease-in-out infinite;&#125;.with-love &#123; color: rgb(255, 113, 113);&#125; (3) hexo clean &amp;&amp; hexo g &amp;&amp; hexo s后完成效果： 第三方服务集成站内搜索NexT 支持集成 Swiftype、 微搜索、Local Search 和 Algolia。在这里我使用的是Local Search，下面将介绍如何使用:(1) 添加百度/谷歌/本地 自定义站点内容搜索，安装hexo-generator-searchdb，在站点的根目录下执行以下命令： 1npm install hexo-generator-searchdb --save (2) 编辑站点配置文件_config.yml，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 (3) 编辑主题配置文件_config.yml，启用本地搜索功能： 123# Local searchlocal_search: enable: true 注：其他搜索方式请查看站内搜索 (4) 清缓存hexo clean，重新生成hexo g，启动服务hexo s，效果如下： 数据统计分析NexT 支持集成 不蒜子统计、百度统计等多种数据统计方式。此处使用不蒜子统计，下面将介绍如何使用: 此特性在版本 5.0.1 中引入，要使用此功能请确保所使用的 NexT 版本在此之后 (1) 全局配置：编辑主题配置文件_config.yml中的busuanzi_count的配置项。当enable: true时，代表开启全局开关。若 site_uv 、site_pv 、 page_pv 的值均为 false 时，不蒜子仅作记录而不会在页面上显示(2) 站点UV配置：当site_uv: true时，代表在页面底部显示站点的UV值。site_uv_header和site_uv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的font-awesome。如下： 1234# 效果：本站访客数12345人次site_uv: truesite_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; 本站访客数site_uv_footer: 人次 (3) 站点PV配置：当site_pv: true时，代表在页面底部显示站点的PV值。site_pv_header和site_pv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的font-awesome。如下： 1234# 效果：本站总访问量12345次site_pv: truesite_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; 本站总访问量site_pv_footer: 次 注：其他统计方式请查看数据统计分析 (4) 清缓存hexo clean，重新生成hexo g，启动服务hexo s，效果如下： (5) 不蒜子统计不生效，浏览器控制台报错原因：由于 busuanzi(不蒜子) 的域名更新，导致了使用 Hexo Next 主题时统计数据失效解决方法： 到 hexo 的 themes 文件夹下, 打开\themes\next\layout_third-party\analytics\busuanzi-counter.swig文件 将src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;修改为src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot; 内容分享服务NexT 支持集成 jiathis、baidushare 和 AddThis内容分享服务。在这里我使用的是baidushare，下面将介绍如何使用:(1) 编辑站点配置文件_config.yml，新增以下内容到任意位置： 1baidushare: true #百度分享功能 (2) 编辑主题配置文件_config.yml，设置其展现方式： 12baidushare: type: button #百度分享展示的方式button|slide 注：其他内容分享方式请查看内容分享服务 (4) 清缓存hexo clean，重新生成hexo g，启动服务hexo s，效果如下： 文章阅读次数统计(1) 在LeanCloud进行对应的配置详细配置参考文章：配置LeanCloud(2) 注Class名称必须为Counter Gitment评论(1) Gitment评论搭建参考：https://sjq597.github.io/2018/05/18/Hexo-使用Gitment评论功能/(2) 踩过的坑： Error: Validation Failed原因：issue的Label有长度限制,对于中文博客来说,中文标题很容易就超过长度限制方案：修改themes/next/layout/_third-party/comments/gitment.swig中的id部分如下: 1234var gitment = new &#123;&#123;CommentsClass&#125;&#125;(&#123; id: '&#123;&#123; page.date &#125;&#125;', owner: '&#123;&#123; theme.gitment.github_user &#125;&#125;', repo: '&#123;&#123; theme.gitment.github_repo &#125;&#125;', object ProgressEvent原因：作者的default.css和gitment.browser.js域名用的别人的，现在过期了方案：修改themes/next/layout/_third-party/comments/gitment.swig中对应部分如下: 1234&lt;!-- &lt;link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"&gt; --&gt;&lt;!-- &lt;script src="https://imsun.github.io/gitment/dist/gitment.browser.js"&gt;&lt;/script&gt; --&gt;&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css"&gt;&lt;script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"&gt;&lt;/script&gt; 注释部分是原来的地址，过期了的，下面的是引用的其他有效地址(3) 汉化：修改themes/next/layout/_third-party/comments/gitment.swig中对应部分如下: 12&lt;link rel="stylesheet" href="https://billts.site/extra_css/gitment.css"&gt;&lt;script src="https://billts.site/js/gitment.js"&gt;&lt;/script&gt; (4) 清缓存hexo clean，重新生成hexo g，部署hexo d，然后访问username.github.io查看效果(5) 每篇文章都需要登录GitHub账号然后点击初始化 来必力评论(1) 登陆来必力获取你的livere_uid 没有账号需要注册一个注册完点击安装，然后填上博客的相应信息，如图data-uid就是所需要的livere_uid(2) 编辑主题配置文件， 编辑livere_uid字段，设置如下: 1livere_uid: #your livere_uid 参考(1) https://cloud.tencent.com/developer/article/1482021(2) https://tianbozhang.coding.me/personal-blog-custom.html(3) https://ehlxr.me/categories/Hexo/(4) https://malizhi.cn/nextTutorial/#more]]></content>
      <categories>
        <category>Hexo个人博客搭建</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Blog</tag>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客搭建-入坑]]></title>
    <url>%2F2018%2F08%2F30%2Fhexo%2Fhexo_blog01%2F</url>
    <content type="text"><![CDATA[前言:使用Node.js+Hexo+Next+Git+GitHub，让你几分钟就能创建一个博客 基本配置(1) Node.js(2) Git(3) GitHub账号及仓库 注：上述条件安装完成后执行后续操作 配置GitHub仓库创建仓库(1) 新建一个名为username.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库(2) 每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库 1.注册的邮箱一定要验证，否则不会成功2.仓库名字必须是：username.github.io，其中username是你的用户名 配置SSH key(1) 提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题(2) 检查本机已存在的ssh密钥：cd ~/. ssh，如果提示No such file or directory说明你是第一次使用Git(3) 生成密钥：ssh-keygen -t rsa -C &quot;邮件地址&quot;，然后三次回车(4) 打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容(5) 打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key，将刚复制的内容粘贴到key那里，title随便填，保存: 测试是否成功(1) 输入命令：ssh -T git@github.com(2) 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes(3) 看到以下信息说明SSH已配置成功： Hi luxiong-github! You’ve successfully authenticated, but GitHub does not provide shell access. 配置Git用户名邮箱(非必须)(1) 执行以下命令： 12git config --global user.name "luxiong-github"// 你的github用户名，非昵称git config --global user.email "xxx@qq.com"// 填写你的github注册邮箱 (2) 配置详情参考：https://blog.csdn.net/sjt19910311/article/details/83685616 创建hexo项目建议使用文本编辑工具管理项目，推荐使用：VSCode、sublime等，我使用的是VSCode 安装Hexo(1) 打开Git Bash，是一个命令输入终端，后序所有命令操作都在此进行(2) 输入命令：npm install -g hexo-cli(3) 如下图: 创建项目文件夹(1) 在Git Bash中切换到博客目录：cd E:React/my-blog/(2) 新建项目目录：hexo init(3) 如下图是在E:\React\my-blog\目录下新建了一个hexo目录 安装依赖包(1) 切换到hexo目录：cd hexo/(2) 安装依赖包：npm install(3) 安装完成后目录结构如下图： 目录结构介绍请看官方API：https://hexo.io/zh-cn/docs/setup 站点配置网站配置1234567title: 卢雄的博客 #网站标题subtitle: Live and learn. #网站副标题description: 要做的事情总找得出时间和机会；不愿意做的事情也总能找得出借口... #网站描述keywords: Blog,Hexo,Github #网站的关键词。使用半角逗号 , 分隔多个关键词author: luxiong #作者language: zh-Hans #语言 en:英文 zh-Hans:简体中文timezone: #网站时区,默认使用电脑的时区 部署配置1234deploy: #部署相关的配置 type: git #使用Git提交 repo: git@github.com:username/username.github.io.git #仓库地址，username替换为Github的username branch: master #分支名称。如果不指定，则默认值为 master 其他详细配置参考文档：https://hexo.io/zh-cn/docs/configuration 预览(1) 生成文件在终端输入命令：hexo g或者hexo generate，作用是将source下面的资源文件在public下生成对应的HTML文件，这些文件将来都是要提交到github去的(2) 启动服务在终端输入命令：hexo s或者hexo server，作用是开启本地预览服务，打开浏览器访问 localhost:4000 即可看到内容，默认的已经写好了一篇名为Hello World的文章(3) 如果浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考：http://blog.liuxianan.com/windows-port-bind.html 其他配置上述只是完成了最基本的博客搭建，还有许多配置仍需完善… 分类(1) 输入命令：hexo new page &quot;categories&quot;(2) 此命令会在source目录下面创建一个categories目录，内含一个index.md文档，打开进行编辑(3) 增加页面类型，结果如下： 123title: categoriesdate: 2019-08-31 13:47:02type: "categories" #将页面的类型设置为categories 标签(1) 输入命令：hexo new page &quot;tags&quot;(2) 此命令会在source目录下面创建一个tags目录，内含一个index.md文档，打开进行编辑(3) 设置页面类型，结果如下： 123title: tagsdate: 2019-08-31 13:47:02type: "tags" #将页面的类型设置为tags about自我介绍页面(1) 输入命令：hexo new page &quot;about&quot;(2) 此命令会在source目录下面创建一个about目录，内含一个index.md文档，打开进行编辑(3) 设置页面类型，结果如下： 123title: aboutdate: 2018-08-31 16:47:02type: "about" # 将页面的类型设置为about 404页面(1) 在source目录下创建一个404.html文件(2) 打开文件，将内容修改为以下内容： 1234567891011121314151617181920&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow" /&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; (3) 此404页面为腾讯公益404页面，也可自定义404页面内容 主题修改(1) 在themes目录下存放的是博客的主题，默认的主题是landscape，可以修改其他主题，推荐使用next主题(2) 将终端切换到hexo目录，执行以下命令： 1git clone https://github.com/iissnan/hexo-theme-next themes/next (3) 修改_config.yml中的theme: landscape改为theme: next，然后重新执行hexo g来重新生成 启用配置(1) 分类、标签、404页面等配置是跟随主题来配置的，所以每次更换主题后都需要启用对应配置才能生效(2) 打开themes -&gt; next目录下的主题配置文件_config.yml，开启以下配置： 123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th #archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap commonweal: /404/ || heartbeat (3) 分别执行以下命令，浏览器访问4000端口进行验证： 123hexo clean # 清除原先生成的public下的文件hexo g # 生成public下的文件hexo s # 启动服务 next主题详细配置参考：http://theme-next.iissnan.com/theme-settings.html 发布文章测试(1) 新建一篇文章：hexo new &quot;测试文章&quot;或者直接在source_posts\目录下面新建测试文章.md文件(2) 打开md文件，按格式书写文章内容： 12345678910---title: 测试标题 # 这是标题tags: # 这里写的标签会自动汇集到 tags 页面上- 测试标签1 # 可配置多个标签，注意格式- 测试标签2category: # 这里写的分类会自动汇集到 categories 页面上，分类可以多级- 测试一级分类 # 一级分类- 测试二级分类 # 二级分类---测试文章内容 (3) 预览： 123hexo clean # 清除原先生成的public下的文件hexo g # 生成public下的文件hexo s # 启动服务 1.修改内容一旦预览与修改不一致，则需要clean2.已发布的文章发生修改， 可直接预览，即 不执行上述3个命令,刷新浏览器即可3.若对md文档语法不熟悉，可参考此文章 上传到GitHub(1) 在之前已经将ssh key和_config.yml关于deploy部分的配置已经完善,不再叙述(2) 直接执行hexo d一般会报如下错误： 1Deployer not found: github 或者 Deployer not found: git 解决方案是安装自动部署发布工具： 1npm install hexo-deployer-git --save (3) 输入命令hexo d将代码上传到GitHub，完成查看GitHub如下：(4) 浏览器访问：yourname.github.io，如果出现博客的内容，说明代码上传成功 总结Hexo相关命令总结(1) 常用命令 1234567891011hexo clean #清除缓存hexo g #生成静态页面至public目录，完整写法为：hexo generatehexo s #启动本地服务，完整写法为：hexo serverhexo d #发布到远程(GitHub)，完整写法为：hexo deployhexo new page "xxx" #新建xxx页面hexo new "xxx" #新建xxx文章hexo help #查看帮助hexo version #查看Hexo的版本hexo init #生成站点npm install --save xxx #安装插件npm unstall xxx #卸载插件 (2) 组合命令 12hexo s -g #生成并本地预览hexo d -g #生成并上传 命令尽量手写少复制粘贴，便于熟悉和理解 问题总结(1) 发布的文章都是md文档，可以先了解一下Markdown语法(2) FATAL Cannot read property ‘replace’ of null问题原因：url不能为空解决：修改站点配置文件_config.yml 1url: http://luxiong-blog.com (3) 静态资源图片设置：\themes\next\source\images\用来存放图片遇到某些地方需要用到图片时(主题配置文件中的avatar、wechatpay、alipay等)，直接使用相对路径引用： 123avatar: /images/avatar.jpg #头像wechatpay: /images/wechatpay.jpg #微信打赏码alipay: /images/alipay.jpg #支付宝打赏码 (4) 阅读全文：生成的博文目录会显示全部的文章内容，在合适的位置加上&lt;!--more--&gt;即可隐藏内容，例如： 12345678910111213# 前言使用github pages服务搭建博客的好处有：1. 全是静态文件，访问速度快；2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；&lt;!--more--&gt;4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；5. 博客内容可以轻松打包、转移、发布到其它平台；6. 等等； 完成效果：(5) 建站问题及错误，遇到问题不要慌，大胆猜测小心验证，百度搜索问题关键字基本都有解决方案 参考(1) https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html(2) https://tianbozhang.coding.me/personal-blog-start.html]]></content>
      <categories>
        <category>Hexo个人博客搭建</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Blog</tag>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
</search>
